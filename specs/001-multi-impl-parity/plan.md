# Implementation Plan: Multi-Implementation Parity Workflow

**Branch**: `001-multi-impl-parity` | **Date**: 2026-02-11 | **Spec**: `specs/001-multi-impl-parity/spec.md`
**Input**: Feature specification from `specs/001-multi-impl-parity/spec.md`

**Note**: This plan was regenerated by `/speckit.plan` reflecting analysis and re-plan. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Primary goal: provide a stepwise parity workflow that compares the C reference
emulator against other implementations over small instruction windows, detects
and reports divergences, and records verified windows in persistent state so
long-running parity efforts can be resumed and inspected.

At a high level, the technical approach is:

- Use a unified test harness to run each implementation for a bounded step
  window and produce traces in the unified format.
- Use an execution-window analyzer to derive structured JSON from traces.
- Use an iterative workflow orchestrator to move window-by-window, persisting
  verification state and generating parity status artifacts.

The C emulator is the reference implementation; all parity judgments are
relative to C. The data model designates C (`id` = `"c"`) as the ground truth.

## Technical Context

**Language/Version**: Python 3.12 (for orchestration scripts); existing C, Zig,
Common Lisp, and TypeScript implementations remain the emulator engines.
**Primary Dependencies**: Standard library only for orchestration (subprocess,
argparse, json, pathlib, signal, tempfile, shutil); existing build toolchains
for each emulator; Typst for documentation.
**Storage**: Files on disk in the repository (JSON state, JSONL logs, trace
files, Typst docs); no external database.
**Testing**: Lightweight Python tests and smoke tests for orchestration scripts
(research D3); existing emulator tests (`zig build test`, C/Laiko/Taiko test
flows) reused for baseline confidence.
**Target Platform**: Linux development environment (project's standard dev
setup), capable of building and running all emulator implementations.
**Project Type**: Single multi-language project (this repository), with
orchestration logic in `scripts/` and implementation-specific code under
`maiko/`, `zaiko/`, `laiko/`, and `taiko/`.
**Performance Goals**: Parity workflow should be able to verify the first 100
steps across all available implementations in under 10 minutes of wall-clock
time on a typical developer machine; longer runs are acceptable for nightly or
ad-hoc deeper checks.
**Constraints**: No `rm` in scripts; workflow must be robust to interruption
and resume from persisted state; all new source files kept under 500 lines and
preferably under 300 lines by modular design.
**Scale/Scope**: Initially focused on step ranges up to at least 0–95 (first
~100 steps), with design that generalizes to larger ranges as needed.

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- **Reference-First (I)**: Plan explicitly treats the C implementation as the
  ground truth when comparing behaviors; all parity judgments are defined
  relative to C traces. ✅
- **Backward Compatibility for Medley Run Scripts (II)**: Workflow works via
  separate orchestration scripts and environment variables; it does not change
  existing Medley run script defaults or semantics. ✅
- **Script Portability and Safety (III)**: New Python scripts avoid interactive
  prompts, use explicit configuration precedence (CLI flags over env over
  defaults), and avoid `rm` by archiving or truncating files safely. ✅
- **Operator-Facing Error Messages (IV)**: Plan requires errors to surface
  clear, user-facing summaries (e.g., "Zig emulator trace missing") followed by
  technical details (paths, exit codes). ✅
- **Concurrency Discipline (V)**: Lock mechanism implemented in T041. Stale-lock
  and cleanup documented in spec.md "Concurrency and Locking". ✅
- **Traceability: Requirements ↔ Tasks (VI)**: For this feature, each FR in
  `spec.md` is mapped to at least one task in `tasks.md`, and the plan
  avoids leaving template placeholders in committed artifacts. ✅

Constitution V (Concurrency Discipline) is satisfied via T041.

## Project Structure

### Documentation (this feature)

```text
specs/001-multi-impl-parity/
├── plan.md              # This file
├── research.md          # Phase 0 output
├── data-model.md        # Phase 1 output
├── contracts/           # API/interface specs (optional); see contracts/README.md
├── quickstart.md        # Phase 1 output
├── tasks.md             # Phase 2 output (/speckit.tasks)
└── checklists/
    └── requirements.md
```

### Source Code (repository root)

Orchestration logic lives in `scripts/`; emulator implementations remain under
`maiko/`, `zaiko/`, `laiko/`, and `taiko/`. Parity workflow artifacts
(`parity_workflow_state.json`, `parity_workflow_dashboard.json`,
`divergence_reports.jsonl`) are written to `reports/parity/`.

```text
scripts/
├── unified_test_harness/        # Package
│   ├── __init__.py
│   ├── main.py                  # CLI, argument parsing
│   ├── runners.py               # C, Zig, Laiko, Taiko emulator runners
│   └── trace_extractor.py       # Trace window extraction, validation
├── unified_test_harness.py      # Wrapper entrypoint
├── execution_window_analysis/  # Package
│   ├── __init__.py
│   ├── parser.py                # Unified trace line parsing
│   └── analyzer.py              # Per-step opcode, stack, registers analysis
├── analyze_execution_window.py  # CLI wrapper for execution analysis
├── iterative_parity_workflow.py # Main orchestrator; state, resume, dashboard
└── compare_unified_traces.py    # Trace comparison (used by workflow)

reports/parity/
├── parity_workflow_state.json   # Persisted workflow state
├── parity_workflow_dashboard.json  # Status artifact
└── divergence_reports.jsonl     # Per-window divergence log
```

**Structure Decision**: Single project layout with orchestration in `scripts/`
and reporting under `reports/parity/`. Emulator implementations are unchanged.
C is the reference; data model aligns with this (see `data-model.md`).

## Complexity Tracking

No active violations. Constitution V (lock mechanism) was deferred initially
and implemented in T041.
