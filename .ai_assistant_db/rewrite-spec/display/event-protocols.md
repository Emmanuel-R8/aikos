# Event Protocols Specification

**Navigation**: [README](README.md) | [Interface Abstraction](interface-abstraction.md) | [Graphics Operations](graphics-operations.md)

Complete specification of event protocols for keyboard, mouse, and window events.

## Overview

Events are generated by the display subsystem and processed by the VM. Events must be translated from platform-specific formats to Lisp event formats.

## Keyboard Events

### Keycode Translation

OS keycodes must be translated to Lisp keycodes:

```pseudocode
function TranslateKeycode(os_keycode, modifiers):
    // Map OS keycode to Lisp keycode
    lisp_keycode = KeycodeMap[os_keycode]

    // Apply modifier encoding
    if modifiers.SHIFT:
        lisp_keycode = ApplyShift(lisp_keycode)
    if modifiers.CONTROL:
        lisp_keycode = ApplyControl(lisp_keycode)
    if modifiers.META:
        lisp_keycode = ApplyMeta(lisp_keycode)

    return lisp_keycode
```

### Keycode Map

Lisp uses its own keycode space:

- **ASCII characters**: Direct mapping (0x00-0x7F)
- **Special keys**: Function keys, arrows, etc. (0x80-0xFF)
- **Modifiers**: Encoded in keycode or separate flags

### Keyboard Event Format

```pseudocode
struct KeyboardEvent:
    type: KEY_PRESS | KEY_RELEASE
    keycode: uint            // Lisp keycode (translated)
    modifiers: bitmask       // Modifier flags
    timestamp: uint           // Event timestamp
```

### Event Processing

```pseudocode
function ProcessKeyboardEvent(event):
    // Translate keycode
    lisp_keycode = TranslateKeycode(event.os_keycode, event.modifiers)

    // Queue event
    QueueKeyEvent(lisp_keycode, event.type)

    // Set interrupt flag
    SetInterruptFlag(IOInterrupt)
```

## Mouse Events

### Mouse Event Format

```pseudocode
struct MouseEvent:
    type: BUTTON_PRESS | BUTTON_RELEASE | MOTION
    button: uint             // Button number (1, 2, 3) or 0 for motion
    x: int                   // X coordinate (in pixels)
    y: int                   // Y coordinate (in pixels)
    modifiers: bitmask       // Modifier keys
    timestamp: uint           // Event timestamp
```

### Button Mapping

**Two-Button Mouse**:

- Button 1: Left button
- Button 2: Right button
- Middle button: Simulated via modifier + right button

**Three-Button Mouse**:

- Button 1: Left button
- Button 2: Middle button
- Button 3: Right button

### Coordinate System

- **Origin**: Top-left corner (0, 0)
- **X-axis**: Increases rightward
- **Y-axis**: Increases downward
- **Units**: Pixels

### Mouse Event Processing

```pseudocode
function ProcessMouseEvent(event):
    // Translate coordinates if needed
    lisp_x = event.x
    lisp_y = event.y

    // Queue mouse event
    QueueMouseEvent(event.type, event.button, lisp_x, lisp_y, event.modifiers)

    // Set interrupt flag
    SetInterruptFlag(IOInterrupt)
```

## Window Events

### Window Event Types

**EXPOSE**: Window exposed (needs redraw)
**RESIZE**: Window resized
**FOCUS_IN**: Window gained focus
**FOCUS_OUT**: Window lost focus
**CLOSE**: Window close requested

### Window Event Format

```pseudocode
struct WindowEvent:
    type: WindowEventType
    width: uint              // New width (for RESIZE)
    height: uint             // New height (for RESIZE)
    timestamp: uint
```

### Window Event Processing

```pseudocode
function ProcessWindowEvent(event):
    switch event.type:
        case EXPOSE:
            // Trigger redraw
            TriggerRedraw()
        case RESIZE:
            // Resize display region
            ResizeDisplayRegion(event.width, event.height)
        case FOCUS_IN:
            // Window gained focus
            SetFocusState(true)
        case FOCUS_OUT:
            // Window lost focus
            SetFocusState(false)
```

## Event Queue

### Event Queue Structure

```pseudocode
struct EventQueue:
    events: array[Event]     // Event buffer
    head: int                // Head pointer
    tail: int                // Tail pointer
    size: int                // Queue size
```

### Queue Operations

```pseudocode
function EnqueueEvent(event):
    if QueueFull():
        Error("Event queue full")

    queue.events[queue.tail] = event
    queue.tail = (queue.tail + 1) mod queue.size

function DequeueEvent() -> Event:
    if QueueEmpty():
        return null

    event = queue.events[queue.head]
    queue.head = (queue.head + 1) mod queue.size
    return event
```

## Event Polling

### Poll Events

```pseudocode
function PollEvents():
    events = []

    // Poll platform events
    platform_events = PlatformPollEvents()

    // Translate and queue events
    for event in platform_events:
        translated_event = TranslateEvent(event)
        EnqueueEvent(translated_event)
        events.append(translated_event)

    return events
```

### Event Translation

```pseudocode
function TranslateEvent(platform_event):
    switch platform_event.type:
        case KEYBOARD_EVENT:
            return TranslateKeyboardEvent(platform_event)
        case MOUSE_EVENT:
            return TranslateMouseEvent(platform_event)
        case WINDOW_EVENT:
            return TranslateWindowEvent(platform_event)
```

## Interrupt Integration

### Event Interrupts

Events trigger I/O interrupts:

```pseudocode
function HandleEventInterrupt():
    // Process pending events
    events = PollEvents()

    for event in events:
        ProcessEvent(event)

    // Set interrupt flag
    SetInterruptFlag(IOInterrupt)
    TriggerInterruptCall(KEYBOARD_FRAME or MOUSE_FRAME)
```

## Related Documentation

- [Interface Abstraction](interface-abstraction.md) - Display interface
- [I/O Systems](../io/) - Keyboard and mouse protocols
- [VM Core](../vm-core/interrupt-handling.md) - Interrupt handling
