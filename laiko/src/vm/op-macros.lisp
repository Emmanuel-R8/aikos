;;;; op-macros.lisp - Comprehensive Opcode Definition System for Laiko
;;;;
;;;; This file defines the DEFOP macro that consolidates all aspects of
;;;; opcode definition into a single, well-documented declaration.
;;;;
;;;; DESIGN GOALS:
;;;;   - Single source of truth for all opcode metadata
;;;;   - O(1) dispatch via arrays for byte->X lookups
;;;;   - Compile-time validation
;;;;   - Auto-generated documentation
;;;;   - Graceful handling of undefined opcodes
;;;;   - Preserve thematic file organization
;;;;
;;;; USAGE:
;;;;   (defop gvar :hexcode #x60 :instruction-length 5
;;;;     "GVAR: Push the value of a global variable."
;;;;     :operands ((atom-index :atom-index "Atom whose value to push"))
;;;;     :stack-effect (:push 1)
;;;;     :category :variable-access
;;;;     :side-effects nil
;;;;     (let ((idx (read-pc-16-be vm)))
;;;;       (push-stack vm (get-atom-value vm idx))))

(in-package :maiko-lisp.vm)

;;; ===========================================================================
;;; STANDARD OPERAND TYPES
;;; ===========================================================================

(deftype operand-type ()
  "Standard operand types for opcode operands.

  Each type specifies how the operand is encoded in the instruction stream:

  :UINT8        - Unsigned 8-bit immediate byte
  :INT8         - Signed 8-bit immediate byte
  :UINT16-BE    - Unsigned 16-bit big-endian (high byte first)
  :INT16-BE     - Signed 16-bit big-endian (high byte first)
  :UINT16-LE    - Unsigned 16-bit little-endian (low byte first)
  :INT16-LE     - Signed 16-bit little-endian (low byte first)
  :UINT32-BE    - Unsigned 32-bit big-endian
  :INT32-BE     - Signed 32-bit big-endian
  :LISP-PTR     - Lisp pointer (32-bit, architecture-dependent)
  :ATOM-INDEX   - Atom table index (16-bit)
  :PC-OFFSET    - PC-relative signed offset for jumps
  :BYTE-COUNT   - Byte count for variable-length operations
  :VARIABLE     - Variable-length operand (count in previous byte)
  :NONE         - No operand (for documentation completeness)
"
  '(member :uint8 :int8 :uint16-be :int16-be :uint16-le :int16-le :uint32-be :int32-be
           :lisp-ptr :atom-index :pc-offset :byte-count :variable :none))

;;; ===========================================================================
;;; GLOBAL STATE
;;; ===========================================================================

;; Primary lookup arrays (byte -> X) - O(1) access during dispatch
;; These are the performance-critical data structures.

(defvar *instruction-lengths*
  (make-array 256 :element-type '(unsigned-byte 8) :initial-element 0)
  "Array mapping opcode byte (0-255) to instruction length in bytes.
  Includes opcode byte itself plus all operand bytes.
  Initialized to 0; undefined opcodes get length 1 during init.")

(defvar *opcode-names*
  (make-array 256 :initial-element nil)
  "Array mapping opcode byte (0-255) to symbolic name.
  NIL for undefined/reserved opcodes.")

(defvar *opcode-handlers-array*
  (make-array 256 :initial-element nil)
  "Array mapping opcode byte (0-255) to handler function.
  NIL slots are filled with default undefined handler during init.")

;; Secondary lookup tables (name -> X) for reverse lookup and introspection

(defvar *opcode-handlers* (make-hash-table :test 'eq)
  "Hash table mapping opcode name (symbol) to handler function.
  Used for name-based lookup (e.g., testing, debugging).")

(defvar *opcode-metadata* (make-hash-table :test 'eq)
  "Hash table mapping opcode name (symbol) to comprehensive metadata plist.
  Contains: :name, :hexcode, :instruction-length, :aliases, :operands,
            :stack-effect, :category, :side-effects, :status, :documentation")

;; Tracking for validation and coverage reporting

(defvar *defined-hexcodes* (make-hash-table :test 'eql)
  "Set of hexcodes (keys) that have been explicitly defined.
  Used to detect duplicate definitions and report coverage.")

(defvar *opcode-documentation* nil
  "Concatenated documentation string for all defined opcodes.
  Generated by GENERATE-OPCODE-DOCUMENTATION.")

;;; ===========================================================================
;;; ERROR CONDITIONS
;;; ===========================================================================

(define-condition opcode-error (error)
  ((opcode :initarg :opcode :reader opcode-error-opcode
           :documentation "The undefined opcode byte value (0-255)")
   (pc :initarg :pc :reader opcode-error-pc
       :documentation "The PC value where the error occurred"))
  (:documentation "Base condition for opcode-related errors."))

(define-condition undefined-opcode-error (opcode-error)
  ((reason :initarg :reason :initform nil :reader undefined-opcode-reason
           :documentation "Why this opcode is undefined"))
  (:report (lambda (condition stream)
             (format stream "Undefined opcode 0x~2,'0X at PC 0x~8,'0X~@[ (~A)~]"
                     (opcode-error-opcode condition)
                     (opcode-error-pc condition)
                     (undefined-opcode-reason condition))))
  (:documentation "Signaled when executing an opcode that is known but not implemented."))

(define-condition reserved-opcode-error (opcode-error)
  ((originally :initarg :originally :initform nil
               :reader reserved-opcode-originally))
  (:report (lambda (condition stream)
             (format stream "Reserved opcode 0x~2,'0X at PC 0x~8,'0X~@[ (originally: ~A)~]"
                     (opcode-error-opcode condition)
                     (opcode-error-pc condition)
                     (reserved-opcode-originally condition))))
  (:documentation "Signaled when executing an opcode reserved for future use or other Lisp variants."))

;;; ===========================================================================
;;; VALIDATION HELPERS (Compile-Time)
;;; ===========================================================================

(defun validate-hexcode (hexcode name)
  "Validate that HEXCODE is in valid range 0-255.
  Warns if HEXCODE was already defined by another opcode.

  Arguments:
    HEXCODE - Integer opcode value
    NAME - Symbol naming this opcode (for error messages)

  Signals ERROR if out of range.
  Signals WARNING if duplicate.
"
  (unless (and (integerp hexcode) (<= 0 hexcode 255))
    (error "DEFOP: Invalid hexcode ~S for opcode ~S: must be integer 0-255"
           hexcode name))
  (let ((existing (gethash hexcode *defined-hexcodes*)))
    (when (and existing (not (eq existing name)))
      (warn "DEFOP: Redefining hexcode 0x~2,'0X: ~S -> ~S"
            hexcode existing name))))

(defun validate-instruction-length (length name)
  "Validate that INSTRUCTION-LENGTH is reasonable (1-15 bytes).

  Arguments:
    LENGTH - Integer instruction length
    NAME - Symbol naming this opcode (for error messages)

  Signals ERROR if invalid.
"
  (unless (and (integerp length) (< 0 length 16))
    (error "DEFOP: Invalid instruction length ~S for opcode ~S: must be 1-15"
           length name)))

(defun validate-stack-effect (effect name)
  "Validate stack effect specification syntax.

  Valid forms:
    (:pop N :push M)           - Pop N, push M
    (:pop-n VAR :push M)       - Pop count from VAR operand
    (:push M)                  - Only push
    (:pop N)                   - Only pop

  Arguments:
    EFFECT - Stack effect plist or NIL
    NAME - Symbol naming this opcode (for error messages)

  Signals ERROR if syntax is invalid.
"
  (when effect
    (unless (listp effect)
      (error "DEFOP: Stack effect for ~S must be a list, got ~S" name effect))
    (loop for (key val) on effect by #'cddr
          unless (member key '(:pop :push :pop-n))
          do (error "DEFOP: Unknown stack effect key ~S for ~S" key name)
          unless val
          do (error "DEFOP: Stack effect key ~S needs a value for ~S" key name))))

(defun validate-operands (operands name)
  "Validate operand specification syntax.

  Each operand is (NAME TYPE [DOCSTRING]).

  Arguments:
    OPERANDS - List of operand specifications
    NAME - Symbol naming this opcode (for error messages)

  Signals ERROR if syntax is invalid or types are unknown.
"
  (when operands
    (unless (listp operands)
      (error "DEFOP: Operands for ~S must be a list, got ~S" name operands))
    (dolist (op operands)
      (unless (and (listp op) (<= 2 (length op) 3))
        (error "DEFOP: Invalid operand spec ~S for ~S: expected (NAME TYPE [DOC])"
               op name))
      (destructuring-bind (op-name op-type &optional op-doc) op
        (declare (ignore op-name op-doc))
        (unless (typep op-type 'operand-type)
          (error "DEFOP: Unknown operand type ~S for ~S (operand ~S)"
                 op-type name op))))))

;;; ===========================================================================
;;; DOCUMENTATION GENERATION
;;; ===========================================================================

(defun generate-opcode-documentation ()
  "Generate and return comprehensive documentation string for all defined opcodes.

  Documentation is organized by category and includes:
    - Opcode name and hexcode
    - Description (from docstring)
    - Operands with types
    - Stack effect
    - Side effects

  Result is cached in *OPCODE-DOCUMENTATION*.
"
  (setf *opcode-documentation*
        (with-output-to-string (s)
          (format s "~&~A~%" (make-string 70 :initial-element #\=))
          (format s "LAIKO OPCODE REFERENCE~%")
          (format s "~A~2%" (make-string 70 :initial-element #\=))

          ;; Document by category
          (dolist (category '(:constants
                              :stack-operations
                              :variable-access
                              :list-operations
                              :arithmetic
                              :comparison
                              :control-flow
                              :function-call
                              :type-operations
                              :bit-operations
                              :miscellaneous
                              :undefined))
            (let ((ops-in-cat nil))
              (maphash
               (lambda (name meta)
                 (when (eq (getf meta :category) category)
                   (push (cons name meta) ops-in-cat)))
               *opcode-metadata*)

              (when ops-in-cat
                (format s "~%~A~%" (make-string 60 :initial-element #\-))
                (format s "~A~2%" (string-capitalize
                                   (format nil "~A (~D opcodes)"
                                           category (length ops-in-cat))))

                (dolist (op (sort ops-in-cat #'< :key (lambda (x) (getf (cdr x) :hexcode))))
                  (destructuring-bind (name . meta) op
                    (let ((hex (getf meta :hexcode))
                          (len (getf meta :instruction-length))
                          (doc (getf meta :documentation))
                          (ops (getf meta :operands))
                          (se (getf meta :stack-effect))
                          (seffects (getf meta :side-effects))
                          (aliases (getf meta :aliases)))

                      ;; Name and hexcode
                      (format s "~%~A (0x~2,'0X)~%" name hex)

                      ;; Description
                      (format s "  ~A~%" (or doc "No description"))

                      ;; Instruction length
                      (format s "  Length: ~D byte~:P~%" len)

                      ;; Aliases
                      (when aliases
                        (format s "  Aliases: ~{~A~^, ~}~%" aliases))

                      ;; Operands
                      (when ops
                        (format s "  Operands:~%")
                        (dolist (op-spec ops)
                          (destructuring-bind (op-name op-type &optional op-doc) op-spec
                            (format s "    ~A: ~A" op-name op-type)
                            (when op-doc
                              (format s " - ~A" op-doc))
                            (format s "~%"))))

                      ;; Stack effect
                      (when se
                        (format s "  Stack: ~{~A ~D~^, ~}~%"
                                (loop for (k v) on se by #'cddr
                                      append (list k v))))

                      ;; Side effects
                      (when seffects
                        (format s "  Side effects: YES~%"))

                      (terpri s)))))))))
  *opcode-documentation*)

;;; ===========================================================================
;;; MAIN MACRO: DEFOP
;;; ===========================================================================

(defun parse-defop-args (args)
  "Parse DEFOP arguments, separating docstring, keywords, and body.
Returns (values docstring plist body-forms).
Docstring may appear at the start or anywhere before the body (when we see
a string while scanning keywords, we take it as the docstring)."
  (let ((docstring nil)
        (plist '())
        (body '())
        (remaining args))
    ;; Scan: optional docstring (first string seen), then keyword/value pairs
    (loop while remaining
          for head = (car remaining)
          do (cond ((stringp head)
                    (setf docstring head)
                    (pop remaining))
                   ((keywordp head)
                    (let ((key (pop remaining)))
                      (when (null remaining)
                        (error "DEFOP: keyword ~S has no value" key))
                      (setf plist (list* (pop remaining) key plist))))
                   (t
                    (return))))
    (setf body remaining)
    (values docstring (nreverse plist) body)))

(defmacro defop (name &rest args)
  "Define an opcode handler with complete metadata.

NAME is a symbol naming this opcode (e.g., 'cons, 'gvar).

ARGS consists of an optional docstring, followed by keyword arguments,
followed by the handler body.

Required keyword arguments:

  HEXCODE is the byte value (0-255) for this opcode.

  INSTRUCTION-LENGTH is total bytes including opcode and operands.

Other keyword arguments:

  ALIASES is a list of alternate names for this opcode.
    Example: (eq?-op pointer-equal)

  OPERANDS is a list of (NAME TYPE [DOC]) describing each operand:
    NAME   - Symbol naming this operand for documentation
    TYPE   - OPERAND-TYPE (see DEFTYPE OPERAND-TYPE)
    DOC    - Optional documentation string
    Example: ((atom-index :atom-index \"Atom to access\"))

  STACK-EFFECT describes stack changes:
    (:pop N :push M)      - Pop N values, push M values
    (:pop-n VAR :push M)  - Pop count from VAR operand
    (:push M)             - Only push
    Example: (:pop 2 :push 1)

  CATEGORY is a keyword for grouping opcodes:
    :constants, :stack-operations, :variable-access, :list-operations,
    :arithmetic, :comparison, :control-flow, :function-call,
    :type-operations, :bit-operations, :miscellaneous

  SIDE-EFFECTS is T if the opcode:
    - Allocates memory (cons, closure, etc.)
    - Writes to memory (rplaca, rplacd, etc.)
    - Has I/O effects
    - Otherwise modifies state beyond the stack

Generated artifacts:
  - Handler function named HANDLE-<NAME>
  - Array entry in *INSTRUCTION-LENGTHS* at HEXCODE
  - Array entry in *OPCODE-NAMES* at HEXCODE
  - Array entry in *OPCODE-HANDLERS-ARRAY* at HEXCODE
  - Hash entry in *OPCODE-HANDLERS* under NAME
  - Hash entry in *OPCODE-METADATA* under NAME

Validation (compile-time):
  - HEXCODE must be 0-255
  - INSTRUCTION-LENGTH must be 1-15
  - Warns on duplicate hexcode definitions
  - Validates stack effect syntax
  - Validates operand types

Example:
  (defop gvar :hexcode #x60 :instruction-length 5
    \"GVAR: Push the value of a global variable.
  The atom index is read from the next 2 bytes (big-endian).\"
    :operands ((atom-index :atom-index \"Atom whose value to push\"))
    :stack-effect (:push 1)
    :category :variable-access
    :side-effects nil
    (let ((idx (read-pc-16-be vm)))
      (push-stack vm (get-atom-value vm idx))))

 "
  (multiple-value-bind (doc-string plist body)
      (parse-defop-args args)
    (let ((hexcode (getf plist :hexcode))
          (instruction-length (getf plist :instruction-length))
          (fn-name (intern (format nil "HANDLE-~A" name)
                           (find-package :maiko-lisp.vm)))
          (aliases (getf plist :aliases))
          (operands (getf plist :operands))
          (stack-effect (getf plist :stack-effect))
          (category (getf plist :category))
          (side-effects (getf plist :side-effects)))
      (unless hexcode
        (error "DEFOP: ~S requires :hexcode" name))
      (unless instruction-length
        (error "DEFOP: ~S requires :instruction-length" name))
      ;; Compile-time validation (expanded into load-time checks)
      `(progn
         ;; === VALIDATION ===
         (validate-hexcode ,hexcode ',name)
         (validate-instruction-length ,instruction-length ',name)
         ,@(when operands
             `((validate-operands ',operands ',name)))
         ,@(when stack-effect
             `((validate-stack-effect ',stack-effect ',name)))

         ;; === TRACK THIS DEFINITION ===
         (setf (gethash ,hexcode *defined-hexcodes*) ',name)

         ;; === PRIMARY ARRAYS (byte -> X) ===

         ;; 1. Instruction length for PC advancement
         (setf (aref *instruction-lengths* ,hexcode) ,instruction-length)

         ;; 2. Opcode name for debugging/display
         (setf (aref *opcode-names* ,hexcode) ',name)

         ;; === HANDLER FUNCTION ===

         ;; 3. Define the handler function
         (defun ,fn-name (vm)
           ,@(when doc-string (list doc-string))
           (declare (type vm vm))
           ,@body)

         ;; 4. Handler in array (byte -> fn) - PRIMARY DISPATCH
         (setf (aref *opcode-handlers-array* ,hexcode) #',fn-name)

         ;; === SECONDARY HASHES (name -> X) ===

         ;; 5. Handler in hash (name -> fn)
         (setf (gethash ',name *opcode-handlers*) #',fn-name)

         ;; 6. Register aliases in handler map
         ,@(when aliases
             (loop for alias in aliases
                   collect `(setf (gethash ',alias *opcode-handlers*) #',fn-name)))

         ;; === METADATA ===

         ;; 7. Comprehensive metadata for introspection
         (setf (gethash ',name *opcode-metadata*)
               (list :name ',name
                     :hexcode ,hexcode
                     :instruction-length ,instruction-length
                     :aliases ',aliases
                     :operands ',operands
                     :stack-effect ',stack-effect
                     :category ',category
                     :side-effects ,side-effects
                     :status :defined
                     :handler-function #',fn-name
                     :documentation ,doc-string))

         ;; === RETURN VALUE ===
         ',fn-name))))

;;; ===========================================================================
;;; UNDEFINED OPCODE MACROS
;;; ===========================================================================

(defmacro defop-undefined (name hexcode &key reason category)
  "Mark an opcode as known but not yet implemented.

Creates a stub handler that signals UNDEFINED-OPCODE-ERROR when executed.
Useful for tracking what needs implementation vs truly unknown opcodes.

NAME is a symbol for documentation (e.g., 'unused-42, 'todo-fancy-op).
HEXCODE is the byte value (0-255).
REASON is a string explaining why undefined (e.g., \"not needed for Medley\").
CATEGORY groups related undefined opcodes for documentation.

The handler will still be valid and return cleanly in the dispatch loop
after signaling the error (if the error is handled).

Example:
  (defop-undefined fancy-list-op #x2B
    :reason \"Only used in Xerox Lisp, not Medley\"
    :category :list-operations)
"
  `(progn
     (validate-hexcode ,hexcode ',name)
     (setf (gethash ,hexcode *defined-hexcodes*) ',name)

     ;; Arrays
     (setf (aref *instruction-lengths* ,hexcode) 1)
     (setf (aref *opcode-names* ,hexcode) ',name)
     (setf (aref *opcode-handlers-array* ,hexcode)
           (lambda (vm)
             (error 'undefined-opcode-error
                    :opcode ,hexcode
                    :pc (vm-pc vm)
                    :reason ,reason)))

     ;; Metadata
     (setf (gethash ',name *opcode-metadata*)
           (list :name ',name
                 :hexcode ,hexcode
                 :status :undefined
                 :reason ,reason
                 :category ,category
                 :documentation (format nil "Undefined: ~A" ,reason)))))

(defmacro defop-reserved (hexcode &key originally-used-in)
  "Mark a hexcode as reserved (not used in this Lisp variant).

Creates a handler that signals RESERVED-OPCODE-ERROR with context.
Use for opcodes that exist in other Lisp variants but not Medley.

HEXCODE is the byte value (0-255).
ORIGINALLY-USED-IN describes historical use (e.g., \"Interlisp only\").

Example:
  (defop-reserved #x0E
    :originally-used-in \"BOUT opcode from Interlisp\")
"
  `(progn
     (setf (gethash ,hexcode *defined-hexcodes*) 'reserved)

     ;; Arrays
     (setf (aref *instruction-lengths* ,hexcode) 1)
     (setf (aref *opcode-names* ,hexcode) 'reserved)
     (setf (aref *opcode-handlers-array* ,hexcode)
           (lambda (vm)
             (error 'reserved-opcode-error
                    :opcode ,hexcode
                    :pc (vm-pc vm)
                    :originally ,originally-used-in)))

     ;; Metadata
     (setf (gethash 'reserved *opcode-metadata*)
           (list :hexcode ,hexcode
                 :status :reserved
                 :originally-used-in ,originally-used-in))))

;;; ===========================================================================
;;; INITIALIZATION AND REPORTING
;;; ===========================================================================

(defun initialize-undefined-opcode-handlers ()
  "Fill any undefined opcode slots with default error handlers.

MUST be called AFTER all DEFOP, DEFOP-UNDEFINED, and DEFOP-RESERVED forms.
Ensures the emulator won't crash on unknown bytes - it will error cleanly.

This function is idempotent and safe to call multiple times.
"
  (loop for hexcode from 0 to 255
        when (null (aref *opcode-handlers-array* hexcode))
        do
        (setf (aref *instruction-lengths* hexcode) 1)
        (setf (aref *opcode-names* hexcode) 'undefined)
        (setf (aref *opcode-handlers-array* hexcode)
              (lambda (vm)
                (error 'undefined-opcode-error
                       :opcode hexcode
                       :pc (vm-pc vm)
                       :reason "Opcode not defined in this Laiko build")))))

(defun report-opcode-coverage (&optional (stream *standard-output*))
  "Report how many opcodes are defined vs undefined.

Useful for tracking implementation progress during development.

Arguments:
  STREAM - Output stream (default *STANDARD-OUTPUT*)

Returns:
  (values defined-count undefined-count coverage-percentage)
"
  (let ((defined 0)
        (undefined 0)
        (by-category (make-hash-table :test 'eq)))

    ;; Count by status
    (maphash (lambda (name meta)
               (declare (ignore name))
               (let ((cat (getf meta :category))
                     (status (getf meta :status)))
                 (when cat
                   (push status (gethash cat by-category)))
                 (if (eq status :defined)
                     (incf defined)
                     (incf undefined))))
             *opcode-metadata*)

    ;; Also count slots with no metadata (truly unknown)
    (loop for hexcode from 0 to 255
          when (null (aref *opcode-handlers-array* hexcode))
          do (incf undefined))

    (let ((coverage (* 100.0 (/ defined 256))))

      ;; Print report
      (format stream "~&~A~%" (make-string 50 :initial-element #\=))
      (format stream "OPCODE COVERAGE REPORT~%")
      (format stream "~A~2%" (make-string 50 :initial-element #\=))

      (format stream "~&Total opcodes (0x00-0xFF): 256~%")
      (format stream "  Defined:   ~3D (~,1F%)~%" defined coverage)
      (format stream "  Undefined: ~3D (~,1F%)~%" undefined (- 100.0 coverage))

      (format stream "~&By Category:~%")
      (dolist (cat '(:constants :stack-operations :variable-access
                     :list-operations :arithmetic :comparison :control-flow
                     :function-call :type-operations :bit-operations
                     :miscellaneous :undefined nil))
        (let ((counts (gethash cat by-category)))
          (when counts
            (let ((def (count :defined counts))
                  (undef (count :undefined counts)))
              (format stream "  ~:[(no category)~;~:*~A~]~25T~3D defined~35T~3D undefined~%"
                      cat def undef)))))

      (format stream "~&~A~%" (make-string 50 :initial-element #\=))

      (values defined undefined coverage))))

(defun list-undefined-opcodes ()
  "Return list of hexcodes that have no handler defined.

Returns:
  List of integers (0-255) for undefined opcodes.
"
  (loop for hexcode from 0 to 255
        when (or (null (aref *opcode-handlers-array* hexcode))
                 (eq (aref *opcode-names* hexcode) 'undefined))
        collect hexcode))

;;; ===========================================================================
;;; CONVENIENCE ACCESSORS
;;; ===========================================================================

(defun get-opcode-info (byte-or-name)
  "Get metadata for an opcode by byte value or name.

Arguments:
  BYTE-OR-NAME - Integer (0-255) or symbol

Returns:
  Property list of metadata, or NIL if not found.
"
  (etypecase byte-or-name
    (integer
     (let ((name (aref *opcode-names* byte-or-name)))
       (when name
         (gethash name *opcode-metadata*))))
    (symbol
     (gethash byte-or-name *opcode-metadata*))))

(defun opcode-name (byte)
  "Get symbolic name for an opcode byte.

Arguments:
  BYTE - Integer 0-255

Returns:
  Symbol naming the opcode, or NIL if undefined.
"
  (aref *opcode-names* byte))

(defun opcode-length (byte)
  "Get instruction length for an opcode byte.

Arguments:
  BYTE - Integer 0-255

Returns:
  Integer length in bytes (at least 1).
"
  (aref *instruction-lengths* byte))

(defun opcode-handler (byte-or-name)
  "Get handler function for an opcode.

Arguments:
  BYTE-OR-NAME - Integer (0-255) or symbol

Returns:
  Function, or NIL if undefined.
"
  (etypecase byte-or-name
    (integer (aref *opcode-handlers-array* byte-or-name))
    (symbol (gethash byte-or-name *opcode-handlers*))))
