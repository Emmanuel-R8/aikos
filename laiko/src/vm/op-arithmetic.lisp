(in-package :maiko-lisp.vm)

;; Integer arithmetic operations
;; iplus2, idifference, itimes2, iquo, irem

(defun handle-iplus2 (vm)
  "IPLUS2: Integer addition"
  (declare (type vm vm))
  (let ((b (pop-stack vm)) (a (pop-stack vm)))
    (let ((a-signed (if (>= a #x80000000) (- a #x100000000) a))
          (b-signed (if (>= b #x80000000) (- b #x100000000) b)))
      (let ((result (+ a-signed b-signed)))
        (let ((result-unsigned (if (minusp result)
                                   (logand (+ result #x100000000) #xFFFFFFFF)
                                   (logand result #xFFFFFFFF))))
          (push-stack vm result-unsigned))))))

(defun handle-idifference (vm)
  "IDIFFERENCE: Integer subtraction (a - b)"
  (declare (type vm vm))
  (let ((b (pop-stack vm)) (a (pop-stack vm)))
    (let ((a-signed (if (>= a #x80000000) (- a #x100000000) a))
          (b-signed (if (>= b #x80000000) (- b #x100000000) b)))
      (let ((result (- a-signed b-signed)))
        (let ((result-unsigned (if (minusp result)
                                   (logand (+ result #x100000000) #xFFFFFFFF)
                                   (logand result #xFFFFFFFF))))
          (push-stack vm result-unsigned))))))

(defun handle-itimes2 (vm)
  "ITIMES2: Integer multiplication"
  (declare (type vm vm))
  (let ((b (pop-stack vm)) (a (pop-stack vm)))
    (let ((a-signed (if (>= a #x80000000) (- a #x100000000) a))
          (b-signed (if (>= b #x80000000) (- b #x100000000) b)))
      (let ((result (* a-signed b-signed)))
        (let ((result-unsigned (if (minusp result)
                                   (logand (+ result #x100000000) #xFFFFFFFF)
                                   (logand result #xFFFFFFFF))))
          (push-stack vm result-unsigned))))))

(defun handle-iquo (vm)
  "IQUO: Integer division (quotient)"
  (declare (type vm vm))
  (let ((b (pop-stack vm)) (a (pop-stack vm)))
    (when (zerop b) (error 'maiko-lisp.utils:vm-arithmetic-error :message "Division by zero"))
    (let ((a-signed (if (>= a #x80000000) (- a #x100000000) a))
          (b-signed (if (>= b #x80000000) (- b #x100000000) b)))
      (let ((result (truncate a-signed b-signed)))
        (let ((result-unsigned (if (minusp result)
                                   (logand (+ result #x100000000) #xFFFFFFFF)
                                   (logand result #xFFFFFFFF))))
          (push-stack vm result-unsigned))))))

(defun handle-irem (vm)
  "IREM: Integer remainder"
  (declare (type vm vm))
  (let ((b (pop-stack vm)) (a (pop-stack vm)))
    (when (zerop b) (error 'maiko-lisp.utils:vm-arithmetic-error :message "Division by zero"))
    (let ((a-signed (if (>= a #x80000000) (- a #x100000000) a))
          (b-signed (if (>= b #x80000000) (- b #x100000000) b)))
      (let ((result (rem a-signed b-signed)))
        (let ((result-unsigned (if (minusp result)
                                   (logand (+ result #x100000000) #xFFFFFFFF)
                                   (logand result #xFFFFFFFF))))
          (push-stack vm result-unsigned))))))

(defun handle-iminus (vm)
  "IMINUS: Negate top of stack"
  (declare (type vm vm))
  (let ((a (pop-stack vm)))
    (let ((a-signed (if (>= a #x80000000) (- a #x100000000) a)))
      (let ((result (- a-signed)))
        (let ((result-unsigned (if (minusp result)
                                   (logand (+ result #x100000000) #xFFFFFFFF)
                                   (logand result #xFFFFFFFF))))
          (push-stack vm result-unsigned))))))

(defun handle-idivide (vm)
  "IDIVIDE: Integer division with remainder"
  (declare (type vm vm))
  (let ((b (pop-stack vm)) (a (pop-stack vm)))
    (when (zerop b) (error 'maiko-lisp.utils:vm-arithmetic-error :message "Division by zero"))
    (let ((a-signed (if (>= a #x80000000) (- a #x100000000) a))
          (b-signed (if (>= b #x80000000) (- b #x100000000) b)))
      (let ((quot (truncate a-signed b-signed))
            (rem (rem a-signed b-signed)))
        (push-stack vm (if (minusp rem)
                          (logand (+ rem #x100000000) #xFFFFFFFF)
                          (logand rem #xFFFFFFFF)))
        (let ((quot-unsigned (if (minusp quot)
                                 (logand (+ quot #x100000000) #xFFFFFFFF)
                                 (logand quot #xFFFFFFFF))))
          (push-stack vm quot-unsigned))))))

(defun handle-imod (vm)
  "IMOD: Integer modulus"
  (declare (type vm vm))
  (let ((b (pop-stack vm)) (a (pop-stack vm)))
    (when (zerop b) (error 'maiko-lisp.utils:vm-arithmetic-error :message "Modulo by zero"))
    (let ((a-signed (if (>= a #x80000000) (- a #x100000000) a))
          (b-signed (if (>= b #x80000000) (- b #x100000000) b)))
      (let ((result (mod a-signed b-signed)))
        (let ((result-unsigned (if (minusp result)
                                   (logand (+ result #x100000000) #xFFFFFFFF)
                                   (logand result #xFFFFFFFF))))
          (push-stack vm result-unsigned))))))
