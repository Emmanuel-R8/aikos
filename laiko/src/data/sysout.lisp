(in-package :maiko-lisp.data)

;; Sysout file reading - IFPAGE structure and reading functions
;; Per maiko/src/ldsout.c and maiko/inc/ifpage.h

;; IFPAGE structure (per maiko/inc/ifpage.h, non-BIGVM case)
(defstruct (ifpage (:conc-name ifpage-))
  "Interface page structure (C IFPAGE from ifpage.h)"
  (currentfxp 0 :type (unsigned-byte 16))
  (resetsfxp 0 :type (unsigned-byte 16))
  (subovfxp 0 :type (unsigned-byte 16))
  (kbdfxp 0 :type (unsigned-byte 16))
  (hardreturnfxp 0 :type (unsigned-byte 16))
  (gcfxp 0 :type (unsigned-byte 16))
  (faultfxp 0 :type (unsigned-byte 16))
  (endofstack 0 :type (unsigned-byte 16))
  (lversion 0 :type (unsigned-byte 16))
  (minrversion 0 :type (unsigned-byte 16))
  (minbversion 0 :type (unsigned-byte 16))
  (rversion 0 :type (unsigned-byte 16))
  (bversion 0 :type (unsigned-byte 16))
  (machinetype 0 :type (unsigned-byte 16))
  (miscfxp 0 :type (unsigned-byte 16))
  (key 0 :type (unsigned-byte 16))
  (serialnumber 0 :type (unsigned-byte 16))
  (emulatorspace 0 :type (unsigned-byte 16))
  (screenwidth 0 :type (unsigned-byte 16))
  (nxtpmaddr 0 :type (unsigned-byte 16))
  (nactivepages 0 :type (unsigned-byte 16))
  (ndirtypages 0 :type (unsigned-byte 16))
  (filepnpmp0 0 :type (unsigned-byte 16))
  (filepnpmt0 0 :type (unsigned-byte 16))
  (teleraidfxp 0 :type (unsigned-byte 16))
  (filler1 0 :type (unsigned-byte 16))
  (filler2 0 :type (unsigned-byte 16))
  (filler3 0 :type (unsigned-byte 16))
  (usernameaddr 0 :type (unsigned-byte 16))
  (userpswdaddr 0 :type (unsigned-byte 16))
  (stackbase 0 :type (unsigned-byte 16))
  (faulthi 0 :type (unsigned-byte 16))
  (faultlo 0 :type (unsigned-byte 16))
  (devconfig 0 :type (unsigned-byte 16))
  (rptsize 0 :type (unsigned-byte 16))
  (rpoffset 0 :type (unsigned-byte 16))
  (wasrptlast 0 :type (unsigned-byte 16))
  (embufvp 0 :type (unsigned-byte 16))
  (nshost0 0 :type (unsigned-byte 16))
  (nshost1 0 :type (unsigned-byte 16))
  (nshost2 0 :type (unsigned-byte 16))
  (mdszone 0 :type (unsigned-byte 16))
  (mdszonelength 0 :type (unsigned-byte 16))
  (emubuffers 0 :type (unsigned-byte 16))
  (emubuflength 0 :type (unsigned-byte 16))
  (process-size 0 :type (unsigned-byte 16))
  (storagefullstate 0 :type (unsigned-byte 16))
  (isfmap 0 :type (unsigned-byte 16))
  (miscstackfn 0 :type (unsigned-byte 32))
  (miscstackarg1 0 :type (unsigned-byte 32))
  (miscstackarg2 0 :type (unsigned-byte 32))
  (miscstackresult 0 :type (unsigned-byte 32))
  (nrealpages 0 :type (unsigned-byte 16))
  (lastlockedfilepage 0 :type (unsigned-byte 16))
  (lastdominofilepage 0 :type (unsigned-byte 16))
  (fptovpstart 0 :type (unsigned-byte 16))
  (fakemousebits 0 :type (unsigned-byte 16))
  (dl24bitaddressable 0 :type (unsigned-byte 16))
  (realpagetableptr 0 :type (unsigned-byte 32))
  (dllastvmempage 0 :type (unsigned-byte 16)))

;; Read functions for endianness handling
(defun read-dlword (stream)
  "Read 16-bit big-endian word from stream."
  (declare (type stream stream))
  (let ((b1 (read-byte stream)) (b2 (read-byte stream)))
    (if (maiko-lisp.utils:little-endian-p)
        (logior (ash b1 8) b2)
        (logior (ash b2 8) b1))))

(defun read-lisp-ptr (stream)
  "Read 32-bit big-endian LispPTR from stream."
  (declare (type stream stream))
  (let ((w1 (read-dlword stream)) (w2 (read-dlword stream)))
    (logior (ash w1 16) w2)))

(defun read-ifpage (stream)
  "Read IFPAGE structure from stream."
  (declare (type stream stream))
  (make-ifpage
   :currentfxp (read-dlword stream) :resetsfxp (read-dlword stream)
   :subovfxp (read-dlword stream) :kbdfxp (read-dlword stream)
   :hardreturnfxp (read-dlword stream) :gcfxp (read-dlword stream)
   :faultfxp (read-dlword stream) :endofstack (read-dlword stream)
   :lversion (read-dlword stream) :minrversion (read-dlword stream)
   :minbversion (read-dlword stream) :rversion (read-dlword stream)
   :bversion (read-dlword stream) :machinetype (read-dlword stream)
   :miscfxp (read-dlword stream) :key (read-dlword stream)
   :serialnumber (read-dlword stream) :emulatorspace (read-dlword stream)
   :screenwidth (read-dlword stream) :nxtpmaddr (read-dlword stream)
   :nactivepages (read-dlword stream) :ndirtypages (read-dlword stream)
   :filepnpmp0 (read-dlword stream) :filepnpmt0 (read-dlword stream)
   :teleraidfxp (read-dlword stream) :filler1 (read-dlword stream)
   :filler2 (read-dlword stream) :filler3 (read-dlword stream)
   :usernameaddr (read-dlword stream) :userpswdaddr (read-dlword stream)
   :stackbase (read-dlword stream) :faulthi (read-dlword stream)
   :faultlo (read-dlword stream) :devconfig (read-dlword stream)
   :rptsize (read-dlword stream) :rpoffset (read-dlword stream)
   :wasrptlast (read-dlword stream) :embufvp (read-dlword stream)
   :nshost0 (read-dlword stream) :nshost1 (read-dlword stream)
   :nshost2 (read-dlword stream) :mdszone (read-dlword stream)
   :mdszonelength (read-dlword stream) :emubuffers (read-dlword stream)
   :emubuflength (read-dlword stream) :process-size (read-dlword stream)
   :storagefullstate (read-dlword stream) :isfmap (read-dlword stream)
   :miscstackfn (read-lisp-ptr stream) :miscstackarg1 (read-lisp-ptr stream)
   :miscstackarg2 (read-lisp-ptr stream) :miscstackresult (read-lisp-ptr stream)
   :nrealpages (read-dlword stream) :lastlockedfilepage (read-dlword stream)
   :lastdominofilepage (read-dlword stream) :fptovpstart (read-dlword stream)
   :fakemousebits (read-dlword stream)
   :dl24bitaddressable (read-dlword stream) :realpagetableptr (read-lisp-ptr stream)
   :dllastvmempage (read-dlword stream)))

(defun read-page (stream)
  "Read 512-byte page, byte-swapped if needed."
  (declare (type stream stream))
  (let ((page (make-array +bytesper-page+ :element-type '(unsigned-byte 8))))
    (read-sequence page stream)
    (when (maiko-lisp.utils:little-endian-p)
      (loop for i from 0 to 510 by 2 do
        (rotatef (aref page i) (aref page (1+ i)))))
    page))

(defun read-fptovp-table (stream fptovp-start num-file-pages)
  "Read FPtoVP table from stream (BIGVM format - 32-bit entries).
   Per Zig implementation and C BIGVM code:
   - BIGVM format: 32-bit entries (u32 array)
   - Each entry: low 16 bits = virtual page, high 16 bits = page OK flag
   - GETFPTOVP: low 16 bits
   - GETPAGEOK: high 16 bits (0xFFFF = sparse page)
   - Size: num_file_pages * 4 bytes
   - Per C: maiko/src/ldsout.c:880 (BIGVM path reads sysout_size * 2 bytes)
   Parameters:
   - num-file-pages: Number of file pages (sysout_size / 2)"
  (declare (type stream stream)
           (type (unsigned-byte 32) num-file-pages))
  (let* ((table-size (* num-file-pages 4)) ; BIGVM: 4 bytes per entry
         (table (make-array num-file-pages :element-type '(unsigned-byte 32) :initial-element 0))
         (last-read-index 0))
    (handler-case
        (loop for i below num-file-pages do
          (setf last-read-index i)
          ;; Read 32-bit entry (big-endian from file)
          (let ((b1 (read-byte stream))
                (b2 (read-byte stream))
                (b3 (read-byte stream))
                (b4 (read-byte stream)))
            (if (maiko-lisp.utils:little-endian-p)
                ;; Byte-swap: file is big-endian, we store as native (little-endian)
                (setf (aref table i) (logior (ash b1 24) (ash b2 16) (ash b3 8) b4))
                ;; Big-endian host: no swap needed
                (setf (aref table i) (logior (ash b1 24) (ash b2 16) (ash b3 8) b4)))))
      (cl:end-of-file ()
        ;; File might be shorter - fill remaining entries with 0xFFFF0000 (sparse)
        ;; Fill from the entry after the last successfully read entry
        (loop for i from (1+ last-read-index) below num-file-pages
              do (setf (aref table i) #xFFFF0000))))
    table))

(defun load-sysout (path)
  "Load sysout file, returning (values ifpage fptovp virtual-memory)."
  (declare (type string path))
  (labels ((inner (stream)
             (file-position stream +ifpage-address+)
             (let ((ifpage (read-ifpage stream)))
               (unless (validate-sysout ifpage)
                 (error 'maiko-lisp.utils:sysout-load-failed
                        :message (format nil "Invalid sysout key: ~X" (ifpage-key ifpage))))
               (file-position stream :end)
               (let* ((file-size (file-position stream))
                      ;; C: sysout_size = (file_size / BYTESPER_PAGE) * 2 (in DLwords/half-pages)
                      ;; num_file_pages = sysout_size / 2
                      (sysout-size-halfpages (* (ash file-size -9) 2)) ; (file_size / 512) * 2
                      (num-file-pages (ash sysout-size-halfpages -1)) ; sysout_size / 2
                      (fptovp-off (calculate-fptovp-offset (ifpage-fptovpstart ifpage))))
                 (file-position stream fptovp-off)
                 ;; Debug: Check FPtoVP offset
                 (format t "  FPtoVP table offset: ~D (fptovpstart=~D)~%" fptovp-off (ifpage-fptovpstart ifpage))
                 (let ((fptovp (read-fptovp-table stream (ifpage-fptovpstart ifpage) num-file-pages)))
                   (let* ((proc-size (ifpage-process-size ifpage))
                          ;; If process-size is 0, use a default size (64MB)
                          ;; This happens when sysout doesn't specify process size
                          (vm-size (* (if (zerop proc-size) 64 proc-size) 1024 1024))
                          (numpages (ash vm-size -9))
                          (vmem (make-array numpages :initial-element nil)))
                     (file-position stream :start)
                     (let ((pages-loaded 0)
                           (valid-pages 0)
                           (first-valid-page nil))
                       ;; Debug: Check FPtoVP table
                       (when (< 0 (length fptovp))
                         (format t "  FPtoVP table: ~D entries, first few: " (length fptovp))
                         (loop for i from 0 below (min 10 (length fptovp))
                               do (let ((vpage (get-fptovp fptovp i))
                                        (pageok (get-page-ok fptovp i)))
                                    (if (= pageok #xFFFF)
                                        (format t "SPARSE ")
                                        (format t "~4,'0X " vpage))))
                         (format t "~%"))
                       (loop for fp from 0 below (length fptovp)
                             do (let ((page-ok (get-page-ok fptovp fp)))
                                  ;; Page is valid if entry != 0xFFFF (per C code: GETPAGEOK != 0177777)
                                  (when (/= page-ok #xFFFF)
                                    (incf valid-pages)
                                    (when (null first-valid-page)
                                      (setf first-valid-page fp))
                                    (let ((pg (make-array +bytesper-page+ :element-type '(unsigned-byte 8) :initial-element 0))
                                          (file-pos (* fp +bytesper-page+))
                                          (vp (get-fptovp fptovp fp)))
                                      (handler-case
                                          (progn
                                            (file-position stream file-pos)
                                            (read-sequence pg stream)
                                            (when (maiko-lisp.utils:little-endian-p)
                                              (loop for i from 0 to 510 by 2 do (rotatef (aref pg i) (aref pg (1+ i)))))
                                            (when (< vp numpages)
                                              (setf (aref vmem vp) pg)
                                              (incf pages-loaded)
                                              (when (<= pages-loaded 3)
                                                (format t "  Loaded page fp=~D -> vp=~D (file-pos=~D)~%" fp vp file-pos)))))
                                        (cl:end-of-file ()
                                          ;; EOF while reading page - file might be shorter than expected
                                          nil)))))
                             finally (progn
                                       (format t "  Valid pages in FPtoVP: ~D, loaded: ~D pages~%" valid-pages pages-loaded)
                                       (when first-valid-page
                                         (format t "  First valid page: fp=~D, vp=~D~%" first-valid-page (get-fptovp fptovp first-valid-page)))
                                       (return (values ifpage fptovp vmem))))))))))
    (handler-case
        (with-open-file (stream path :element-type '(unsigned-byte 8) :direction :input)
          (inner stream))
      (file-error (e)
        (error 'maiko-lisp.utils:sysout-load-failed
               :message (format nil "Cannot open ~A: ~A" path e)))
      (cl:end-of-file ()
        (error 'maiko-lisp.utils:sysout-load-failed
               :message (format nil "Unexpected EOF in ~A" path))))))
