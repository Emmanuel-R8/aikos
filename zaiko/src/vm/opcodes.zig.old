const std = @import("std");
const errors = @import("../utils/errors.zig");
const stack = @import("stack.zig");
const types = @import("../utils/types.zig");
const cons = @import("../data/cons.zig");
const array = @import("../data/array.zig");
const virtual_memory_module = @import("../memory/virtual.zig");

const VM = stack.VM;
const LispPTR = types.LispPTR;
const DLword = types.DLword;

/// GCREF: Garbage collection reference counting
/// Per C implementation: maiko/src/gc.c:OP_gcref
/// alpha operand: ADDREF (0), DELREF (1), or STKREF (2)
/// TopOfStack is the slot address to reference count
/// TODO: Implement full GC hash table lookup (Phase 4)
pub fn handleGCREF(vm: *VM, alpha: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    _ = alpha; // TODO: Use alpha to determine ADDREF/DELREF/STKREF operation

    // For now, just leave TopOfStack alone (stub implementation)
    // Full implementation will call GCLOOKUPV with TopOfStack and alpha
    // and replace TopOfStack with 0 if refcnt != 0
    _ = stack_module.getTopOfStack(vm);
}

/// Arithmetic opcode handlers
/// Per rewrite documentation opcodes.md
/// IPLUS2: Integer plus 2 operands
/// Per rewrite documentation instruction-set/opcodes.md
/// Matches C implementation: maiko/src/arithops.c:N_OP_iplus2
pub fn handleIPLUS2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const types_module = @import("../utils/types.zig");

    // Pop two values from stack (order: tos, tosm1)
    const tos = try stack_module.popStack(vm);
    const tosm1 = try stack_module.popStack(vm);

    // Extract integers using N_IGETNUMBER equivalent
    const arg1 = types_module.extractInteger(tosm1) catch return error.InvalidNumberType;
    const arg2 = types_module.extractInteger(tos) catch return error.InvalidNumberType;

    // Perform addition with overflow checking (matches C implementation)
    const result_int = arg1 + arg2;

    // Check for overflow (matches C overflow detection)
    if (((arg1 >= 0) == (arg2 >= 0)) and ((result_int >= 0) != (arg1 >= 0))) {
        return error.InvalidOpcode; // Overflow - matches C ERROR_EXIT behavior
    }

    // Encode result using N_ARITH_SWITCH equivalent
    const result = try types_module.encodeIntegerResult(result_int);

    // Push result
    try stack_module.pushStack(vm, result);
}

/// IDIFFERENCE: Integer difference
/// Per rewrite documentation instruction-set/opcodes.md
/// Matches C implementation: maiko/src/arithops.c:N_OP_idifference
pub fn handleIDIFFERENCE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const types_module = @import("../utils/types.zig");

    // Pop two values from stack (order: tos, tosm1)
    const tos = try stack_module.popStack(vm);
    const tosm1 = try stack_module.popStack(vm);

    // Extract integers using N_IGETNUMBER equivalent
    const arg1 = types_module.extractInteger(tosm1) catch return error.InvalidNumberType;
    const arg2 = types_module.extractInteger(tos) catch return error.InvalidNumberType;

    // Perform subtraction with overflow checking (matches C implementation)
    const result_int = arg1 - arg2;

    // Check for overflow (matches C overflow detection)
    if (((arg1 >= 0) == (arg2 < 0)) and ((result_int >= 0) != (arg1 >= 0))) {
        return error.InvalidOpcode; // Overflow - matches C ERROR_EXIT behavior
    }

    // Encode result using N_ARITH_SWITCH equivalent
    const result = try types_module.encodeIntegerResult(result_int);

    try stack_module.pushStack(vm, result);
}

/// ITIMES2: Integer times 2 operands
/// Per rewrite documentation instruction-set/opcodes.md
/// Matches C implementation: maiko/src/arithops.c:N_OP_itimes2
pub fn handleITIMES2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const types_module = @import("../utils/types.zig");

    // Pop two values from stack (order: tos, tosm1)
    const tos = try stack_module.popStack(vm);
    const tosm1 = try stack_module.popStack(vm);

    // Extract integers using N_IGETNUMBER equivalent
    const arg1 = types_module.extractInteger(tosm1) catch return error.InvalidNumberType;
    const arg2 = types_module.extractInteger(tos) catch return error.InvalidNumberType;

    // Perform multiplication with overflow checking (matches C implementation)
    const result_int = arg1 * arg2;

    // Check for overflow (matches C overflow detection)
    if (((arg1 >= 0) == (arg2 >= 0)) and ((result_int >= 0) != (arg1 >= 0))) {
        return error.InvalidOpcode; // Overflow - matches C ERROR_EXIT behavior
    }

    // Encode result using N_ARITH_SWITCH equivalent
    const result = try types_module.encodeIntegerResult(result_int);

    try stack_module.pushStack(vm, result);
}

/// IQUO: Integer quotient
/// Per rewrite documentation instruction-set/opcodes.md
/// Matches C implementation: maiko/src/arithops.c:N_OP_iquotient
pub fn handleIQUO(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const types_module = @import("../utils/types.zig");

    // Pop two values from stack (order: tos, tosm1)
    const tos = try stack_module.popStack(vm);
    const tosm1 = try stack_module.popStack(vm);

    // Extract integers using N_IGETNUMBER equivalent
    const arg1 = types_module.extractInteger(tosm1) catch return error.InvalidNumberType;
    const arg2 = types_module.extractInteger(tos) catch return error.InvalidNumberType;

    // Check for division by zero
    if (arg2 == 0) {
        return error.DivisionByZero;
    }

    // Perform division (matches C implementation: uses integer division)
    const result_int = @divTrunc(arg1, arg2);

    // Encode result using N_ARITH_SWITCH equivalent
    const result = try types_module.encodeIntegerResult(result_int);

    try stack_module.pushStack(vm, result);
}

/// IREM: Integer remainder
/// Per rewrite documentation instruction-set/opcodes.md
/// Matches C implementation: maiko/src/arithops.c:N_OP_iremainder
pub fn handleIREM(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const types_module = @import("../utils/types.zig");

    // Pop two values from stack (order: tos, tosm1)
    const tos = try stack_module.popStack(vm);
    const tosm1 = try stack_module.popStack(vm);

    // Extract integers using N_IGETNUMBER equivalent
    const arg1 = types_module.extractInteger(tosm1) catch return error.InvalidNumberType;
    const arg2 = types_module.extractInteger(tos) catch return error.InvalidNumberType;

    // Check for division by zero
    if (arg2 == 0) {
        return error.DivisionByZero;
    }

    // Perform remainder operation (matches C implementation)
    const result_int = @rem(arg1, arg2);

    // Encode result using N_ARITH_SWITCH equivalent
    const result = try types_module.encodeIntegerResult(result_int);

    try stack_module.pushStack(vm, result);
}

// ============================================================================
// General Arithmetic Operations
// ============================================================================

/// PLUS2: General addition (handles integers and floats)
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops two values, performs addition, pushes result
/// Falls back to float addition if not integers
pub fn handlePLUS2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // Check if both are integers (low bit = 0 for fixnums)
    // For now, treat as integer addition (will be extended for floats)
    const a_signed = @as(i32, @bitCast(@as(u32, a)));
    const b_signed = @as(i32, @bitCast(@as(u32, b)));
    const result = @as(LispPTR, @bitCast(@as(u32, @intCast(a_signed + b_signed))));

    try stack_module.pushStack(vm, result);
}

/// DIFFERENCE: General subtraction (handles integers and floats)
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops two values, performs subtraction (a - b), pushes result
pub fn handleDIFFERENCE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // For now, treat as integer subtraction (will be extended for floats)
    const a_signed = @as(i32, @bitCast(@as(u32, a)));
    const b_signed = @as(i32, @bitCast(@as(u32, b)));
    const result = @as(LispPTR, @bitCast(@as(u32, @intCast(a_signed - b_signed))));

    try stack_module.pushStack(vm, result);
}

/// TIMES2: General multiplication (handles integers and floats)
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops two values, performs multiplication, pushes result
pub fn handleTIMES2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // For now, treat as integer multiplication (will be extended for floats)
    const a_signed = @as(i32, @bitCast(@as(u32, a)));
    const b_signed = @as(i32, @bitCast(@as(u32, b)));
    const result = @as(LispPTR, @bitCast(@as(u32, @intCast(a_signed * b_signed))));

    try stack_module.pushStack(vm, result);
}

/// QUOTIENT: General division (handles integers and floats)
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops two values, performs division (a / b), pushes result
pub fn handleQUOTIENT(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    if (b == 0) {
        return errors_module.VMError.InvalidAddress; // Division by zero
    }

    // For now, treat as integer division (will be extended for floats)
    const a_signed = @as(i32, @bitCast(@as(u32, a)));
    const b_signed = @as(i32, @bitCast(@as(u32, b)));
    const result = @as(LispPTR, @bitCast(@as(u32, @intCast(@divTrunc(a_signed, b_signed)))));

    try stack_module.pushStack(vm, result);
}

// ============================================================================
// Bitwise Operations
// ============================================================================

/// LOGOR2: Logical OR (bitwise OR)
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops two values, performs bitwise OR, pushes result
pub fn handleLOGOR2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // Perform bitwise OR
    const result: LispPTR = a | b;

    try stack_module.pushStack(vm, result);
}

/// LOGAND2: Logical AND (bitwise AND)
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops two values, performs bitwise AND, pushes result
pub fn handleLOGAND2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // Perform bitwise AND
    const result: LispPTR = a & b;

    try stack_module.pushStack(vm, result);
}

/// LOGXOR2: Logical XOR (bitwise XOR)
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops two values, performs bitwise XOR, pushes result
pub fn handleLOGXOR2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // Perform bitwise XOR
    const result: LispPTR = a ^ b;

    try stack_module.pushStack(vm, result);
}

/// LSH: Logical shift
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops shift amount and value, performs logical shift, pushes result
/// Positive shift amount = left shift, negative = right shift
pub fn handleLSH(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // Pop shift amount and value
    const shift_amount = try stack_module.popStack(vm);
    const value = try stack_module.popStack(vm);

    // Convert shift amount to signed integer
    const shift_signed = @as(i32, @bitCast(@as(u32, shift_amount)));

    // Perform shift operation
    const result: LispPTR = if (shift_signed >= 0) blk: {
        // Left shift
        const shift_u = @as(u5, @intCast(shift_signed));
        // Clamp shift amount to avoid undefined behavior
        const safe_shift = @min(shift_u, 31);
        break :blk value << safe_shift;
    } else blk: {
        // Right shift (logical right shift, zero-fill)
        const shift_u = @as(u5, @intCast(-shift_signed));
        const safe_shift = @min(shift_u, 31);
        break :blk value >> safe_shift;
    };

    try stack_module.pushStack(vm, result);
}

/// LLSH1: Logical left shift by 1
/// Per rewrite documentation instruction-set/opcodes.md
/// Shifts TOS left by 1 bit
pub fn handleLLSH1(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const value = stack_module.getTopOfStack(vm);
    const result: LispPTR = value << 1;

    stack_module.setTopOfStack(vm, result);
}

/// LLSH8: Logical left shift by 8
/// Per rewrite documentation instruction-set/opcodes.md
/// Shifts TOS left by 8 bits
pub fn handleLLSH8(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const value = stack_module.getTopOfStack(vm);
    const result: LispPTR = value << 8;

    stack_module.setTopOfStack(vm, result);
}

/// LRSH1: Logical right shift by 1
/// Per rewrite documentation instruction-set/opcodes.md
/// Shifts TOS right by 1 bit (logical, zero-fill)
pub fn handleLRSH1(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const value = stack_module.getTopOfStack(vm);
    const result: LispPTR = value >> 1;

    stack_module.setTopOfStack(vm, result);
}

/// LRSH8: Logical right shift by 8
/// Per rewrite documentation instruction-set/opcodes.md
/// Shifts TOS right by 8 bits (logical, zero-fill)
pub fn handleLRSH8(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const value = stack_module.getTopOfStack(vm);
    const result: LispPTR = value >> 8;

    stack_module.setTopOfStack(vm, result);
}

/// Stack manipulation opcodes
/// PUSH: Push value onto stack
/// Per rewrite documentation instruction-set/opcodes.md
/// Note: PUSH typically pushes a constant value from instruction operand
/// For now, simplified version pushes 0
pub fn handlePUSH(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // PUSH typically pushes a constant value from instruction operand
    // TODO: Extract constant value from instruction operand
    // For now, push 0 (will need to get value from instruction operand)
    try stack_module.pushStack(vm, 0);
}

/// POP: Pop value from stack
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handlePOP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    _ = try stack_module.popStack(vm); // Discard value
}

/// POP_N: Pop N values from stack
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops count values from stack, discarding them
pub fn handlePOP_N(vm: *VM, count: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Pop count values from stack
    var i: u8 = 0;
    while (i < count) : (i += 1) {
        _ = stack_module.popStack(vm) catch |err| {
            // If we can't pop enough values, return error
            return switch (err) {
                errors_module.VMError.StackUnderflow => err,
                else => errors_module.VMError.StackUnderflow,
            };
        };
    }
}

/// SWAP: Swap top two stack values
/// Per rewrite documentation instruction-set/opcodes.md
/// Swaps the top two values on the stack
pub fn handleSWAP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // Pop top two values
    const top = try stack_module.popStack(vm);
    const second = try stack_module.popStack(vm);

    // Push them back in swapped order
    try stack_module.pushStack(vm, top);
    try stack_module.pushStack(vm, second);
}

/// NOP: No operation
/// Per rewrite documentation instruction-set/opcodes.md
/// Does nothing, just advances PC
pub fn handleNOP(vm: *VM) errors.VMError!void {
    // No operation - just advance PC (handled by dispatch loop)
    _ = vm;
}

/// FN0-FN4: Function call opcodes with fixed argument counts
/// Per rewrite documentation instruction-set/opcodes.md and vm-core/function-calls.md
/// Matches C implementation: maiko/inc/tosfns.h:OPFN
///
/// FN0 (0x08): Call function with 0 arguments
/// FN1 (0x09): Call function with 1 argument
/// FN2 (0x0A): Call function with 2 arguments
/// FN3 (0x0B): Call function with 3 arguments
/// FN4 (0x0C): Call function with 4 arguments
///
/// Instruction format: [opcode][atom_index_byte]
/// Stack: [arg_N, ..., arg_0, function_obj] -> []
pub fn handleFN0(vm: *VM, instruction: *const @import("dispatch.zig").Instruction) errors.VMError!void {
    try handleFN(vm, instruction, 0);
}

pub fn handleFN1(vm: *VM, instruction: *const @import("dispatch.zig").Instruction) errors.VMError!void {
    try handleFN(vm, instruction, 1);
}

pub fn handleFN2(vm: *VM, instruction: *const @import("dispatch.zig").Instruction) errors.VMError!void {
    try handleFN(vm, instruction, 2);
}

pub fn handleFN3(vm: *VM, instruction: *const @import("dispatch.zig").Instruction) errors.VMError!void {
    try handleFN(vm, instruction, 3);
}

pub fn handleFN4(vm: *VM, instruction: *const @import("dispatch.zig").Instruction) errors.VMError!void {
    try handleFN(vm, instruction, 4);
}

/// Common FN handler implementation
/// Matches C implementation: maiko/inc/tosfns.h:OPFN
fn handleFN(vm: *VM, instruction: *const @import("dispatch.zig").Instruction, arg_count: u8) errors.VMError!void {
    const function_module = @import("function.zig");

    // Get atom index from instruction operand (2 bytes after opcode for non-BIGATOMS)
    // C: Get_AtomNo_PCMAC1 - gets atom index as DLword (2 bytes) from PC+1
    // For non-BIGATOMS: Get_AtomNo(ptr) = Get_DLword(ptr) - 2 bytes
    const atom_index: LispPTR = instruction.getWordOperand(0); // DLword (2 bytes) for non-BIGATOMS

    // TODO: Lookup function definition from atom table
    // C: defcell = GetDEFCELL68k(atom_index)
    // For now, we'll create a placeholder function header
    // Full implementation will need atom table lookup (Phase 3)

    // Placeholder: Create a minimal function header
    // This will be replaced with proper atom table lookup
    // Note: na is DLword (u16) in FunctionHeader struct, but C uses short (signed)
    // For now, we store as u16 and will handle signed interpretation when needed
    var func_header = function_module.FunctionHeader{
        .stkmin = 0,
        .na = @as(DLword, @intCast(arg_count)), // Number of arguments (negative if spread, but stored as u16)
        .pv = 0, // Parameter variable count
        .startpc = 0, // Code start offset
        .framename = atom_index, // Frame name atom index
        .ntsize = 0,
        .nlocals = 0,
        .fvaroffset = 0,
    };

    // Call function with argument count
    // C: OPFN sets up frame, pushes TOS, handles spread args, sets up BF/FX markers
    try function_module.callFunction(vm, &func_header, arg_count);
}

/// RETURN: Return from function
/// Per rewrite documentation instruction-set/opcodes.md and vm-core/function-calls.md
/// Matches C implementation: maiko/inc/tosret.h:OPRETURN
pub fn handleRETURN(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const function_module = @import("function.zig");

    // Get return value and restore frame
    // C: OPRETURN gets return value from TOPOFSTACK, restores previous frame via alink
    const return_value = try function_module.returnFromFunction(vm);

    // Set return value on stack (TOS)
    // C: TOPOFSTACK is preserved through frame restoration
    stack_module.setTopOfStack(vm, return_value);
}

// ============================================================================
// Binding Operations
// ============================================================================

/// BIND: Bind variables from stack
/// Per rewrite documentation instruction-set/opcodes.md
/// Binds count variable-value pairs from stack
/// Stack: [value_N, atom_N, ..., value_0, atom_0] -> []
pub fn handleBIND(vm: *VM, count: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // BIND requires:
    // 1. Atom table access (needs atom table structure)
    // 2. Binding frame allocation
    // 3. Variable binding storage

    // TODO: Proper implementation needs:
    // 1. Atom table lookup for each atom_index
    // 2. Binding frame (BF) allocation
    // 3. Store bindings in binding frame
    // 4. Link binding frame to current frame

    // For now, pop count pairs from stack (atom_index, value)
    var i: u8 = 0;
    while (i < count) : (i += 1) {
        const value = try stack_module.popStack(vm);
        const atom_index = try stack_module.popStack(vm);
        _ = value;
        _ = atom_index; // Will be used when binding system is implemented
    }
}

/// UNBIND: Unbind variables
/// Per rewrite documentation instruction-set/opcodes.md
/// Unbinds variables in reverse bind order
pub fn handleUNBIND(vm: *VM) errors.VMError!void {
    // UNBIND requires:
    // 1. Binding frame access
    // 2. Restore previous variable values
    // 3. Deallocate binding frame

    // TODO: Proper implementation needs:
    // 1. Get current binding frame
    // 2. Restore variable values
    // 3. Unlink and deallocate binding frame

    _ = vm; // Will be used when binding system is implemented
}

/// DUNBIND: Dynamic unbind
/// Per rewrite documentation instruction-set/opcodes.md
/// Unbind with dynamic scope handling
pub fn handleDUNBIND(vm: *VM) errors.VMError!void {
    // DUNBIND requires:
    // 1. Dynamic scope handling
    // 2. Binding frame traversal
    // 3. Variable value restoration

    // TODO: Proper implementation needs:
    // 1. Dynamic scope lookup
    // 2. Binding frame traversal
    // 3. Variable value restoration

    _ = vm; // Will be used when binding system is implemented
}

/// Control flow opcodes
/// JUMP: Unconditional jump
/// Per rewrite documentation instruction-set/opcodes.md
/// Note: PC update is handled by dispatch loop based on returned offset
pub fn handleJUMP(vm: *VM) errors.VMError!void {
    // JUMP is unconditional - dispatch loop handles PC update
    _ = vm;
}

// ============================================================================
// Control Flow Opcodes
// ============================================================================

/// FJUMP: False jump (jump if NIL)
/// Per rewrite documentation instruction-set/opcodes.md
/// Note: PC update is handled by dispatch loop based on condition and returned offset
pub fn handleFJUMP(vm: *VM, offset: i8) errors.VMError!void {
    // FJUMP logic is handled in dispatch loop
    // This handler exists for consistency and potential side effects
    _ = vm;
    _ = offset;
}

/// TJUMP: True jump (jump if not NIL)
/// Per rewrite documentation instruction-set/opcodes.md
/// Note: PC update is handled by dispatch loop based on condition and returned offset
pub fn handleTJUMP(vm: *VM, offset: i8) errors.VMError!void {
    // TJUMP logic is handled in dispatch loop
    // This handler exists for consistency and potential side effects
    _ = vm;
    _ = offset;
}

/// JUMPX: Extended jump (16-bit offset)
/// Per rewrite documentation instruction-set/opcodes.md
/// Note: PC update is handled by dispatch loop based on returned offset
pub fn handleJUMPX(vm: *VM) errors.VMError!void {
    // JUMPX is unconditional - dispatch loop handles PC update
    _ = vm;
}

/// FJUMPX: Extended false jump (16-bit offset, jump if NIL)
/// Per rewrite documentation instruction-set/opcodes.md
/// Note: PC update is handled by dispatch loop based on condition and returned offset
pub fn handleFJUMPX(vm: *VM, offset: i16) errors.VMError!void {
    // FJUMPX logic is handled in dispatch loop
    // This handler exists for consistency and potential side effects
    _ = vm;
    _ = offset;
}

/// TJUMPX: Extended true jump (16-bit offset, jump if not NIL)
/// Per rewrite documentation instruction-set/opcodes.md
/// Note: PC update is handled by dispatch loop based on condition and returned offset
pub fn handleTJUMPX(vm: *VM, offset: i16) errors.VMError!void {
    // TJUMPX logic is handled in dispatch loop
    // This handler exists for consistency and potential side effects
    _ = vm;
    _ = offset;
}

// ============================================================================
// Data Access Opcodes
// ============================================================================

/// CAR: Get CAR of list
/// Per rewrite documentation instruction-set/opcodes.md
/// CAR: Get CAR of list
/// Per rewrite documentation instruction-set/opcodes.md
/// Matches C implementation: maiko/inc/inlineC.h:OPCAR
pub fn handleCAR(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    const list_ptr = stack_module.getTopOfStack(vm);

    // C: Check Listp(TOPOFSTACK) first, then handle NIL_PTR and ATOM_T
    // For now, we check NIL first (simpler)
    if (list_ptr == 0) {
        // NIL - CAR of NIL is NIL (C: nextop1, value unchanged)
        return;
    }

    // TODO: Check if list_ptr == ATOM_T (1) - CAR of T is T
    // TODO: Check Listp(list_ptr) - if not a list, goto op_ufn (UFN lookup)

    // Get cons cell from memory using address translation
    if (vm.virtual_memory) |_vmem| {
        // Translate LispPTR to native pointer (4-byte aligned for cons cell)
        // C: NativeAligned4FromLAddr(TOPOFSTACK)
        const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(list_ptr, fptovp_table, 4) catch {
            // Invalid address - trigger UFN (for now, leave value unchanged)
            return;
        };

        // Cast to cons cell pointer
        const cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(native_ptr)));

        // Handle indirect CDR encoding
        // C: if (DATUM68K->cdr_code == CDR_INDIRECT) { TOPOFSTACK = indirect_cell->car_field }
        var car_value = cons.getCAR(cell);
        if (cell.cdr_code == cons.CDR_INDIRECT) {
            // CAR is stored in indirect cell
            // C: TOPOFSTACK = ((ConsCell *)NativeAligned4FromLAddr(DATUM68K->car_field))->car_field
            const indirect_addr = car_value;
            const indirect_native = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(indirect_addr, fptovp_table, 4) catch {
                return;
            } else {
                return;
            };
            const indirect_cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(indirect_native)));
            car_value = cons.getCAR(indirect_cell);
        }

        // C: TOPOFSTACK = car_value; nextop1;
        stack_module.setTopOfStack(vm, car_value);
    } else {
        // No virtual memory - can't access memory
        return errors_module.VMError.MemoryAccessFailed;
    }
}

/// CDR: Get CDR of list
/// Per rewrite documentation instruction-set/opcodes.md
/// Matches C implementation: maiko/inc/inlineC.h:OPCDR (NEWCDRCODING version)
pub fn handleCDR(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    const list_ptr = stack_module.getTopOfStack(vm);

    // C: Check Listp(TOPOFSTACK) first, then handle NIL_PTR
    if (list_ptr == 0) {
        // NIL - CDR of NIL is NIL (C: nextop1, value unchanged)
        return;
    }

    // TODO: Check Listp(list_ptr) - if not a list, goto op_ufn (UFN lookup)

    // Get cons cell from memory using address translation
    if (vm.virtual_memory) |_vmem| {
        // Translate LispPTR to native pointer (4-byte aligned for cons cell)
        // C: NativeAligned4FromLAddr(TOPOFSTACK)
        const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(list_ptr, fptovp_table, 4) catch {
            // Invalid address - trigger UFN (for now, leave value unchanged)
            return;
        };

        // Cast to cons cell pointer
        const cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(native_ptr)));

        // Decode CDR using CDR coding (NEWCDRCODING version)
        // C: CDRCODEX = DATUM68K->cdr_code
        const cdr_code = cell.cdr_code;

        var cdr_value: LispPTR = 0;

        // C: NEWCDRCODING version (matches maiko/inc/inlineC.h:122-150)
        if (cdr_code == cons.CDR_NIL) {
            // C: CDR_NIL (8) -> TOPOFSTACK = NIL_PTR
            cdr_value = 0;
        } else if (cdr_code > cons.CDR_ONPAGE_MIN) {
            // C: CDR_ONPAGE (8-15) -> TOPOFSTACK = TOPOFSTACK + ((CDRCODEX & 7) << 1)
            // Same page encoding: 3-bit offset
            const offset = (@as(u32, cdr_code) & 7) << 1;
            cdr_value = list_ptr + offset;
        } else if (cdr_code == cons.CDR_INDIRECT) {
            // C: CDR_INDIRECT (0) -> TOPOFSTACK = cdr(DATUM68K->car_field) (recursive)
            // Recursive CDR call on indirect cell
            const indirect_addr = cons.getCAR(cell);
            const indirect_native = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(indirect_addr, fptovp_table, 4) catch {
                return;
            } else {
                return;
            };
            const indirect_cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(indirect_native)));
            // Recursive call to getCDR
            cdr_value = cons.getCDR(indirect_cell, indirect_addr);
        } else {
            // C: CDR different page (1-7) -> TOPOFSTACK = ((ConsCell *)NativeAligned4FromLAddr(TOPOFSTACK + (CDRCODEX << 1)))->car_field
            // Different page encoding: CDR stored in another cell's CAR field
            const offset = @as(u32, cdr_code) << 1;
            const cdr_addr = list_ptr + offset;
            const cdr_native = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(cdr_addr, fptovp_table, 4) catch {
                return;
            } else {
                return;
            };
            const cdr_cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(cdr_native)));
            cdr_value = cons.getCAR(cdr_cell);
        }

        // C: TOPOFSTACK = cdr_value; nextop1;
        stack_module.setTopOfStack(vm, cdr_value);
    } else {
        // No virtual memory - can't access memory
        return errors_module.VMError.MemoryAccessFailed;
    }
}

/// CONS: Create cons cell
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleCONS(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const storage_module = @import("../memory/storage.zig");
    const errors_module = @import("../utils/errors.zig");

    // Pop CDR and CAR values
    const cdr_value = try stack_module.popStack(vm);
    const car_value = try stack_module.popStack(vm);

    // Allocate cons cell from storage
    if (vm.storage) |storage| {
        const cell_addr = storage_module.allocateConsCell(storage) catch |err| {
            return switch (err) {
                error.StorageFull => errors_module.VMError.StorageFull,
                else => errors_module.VMError.MemoryAccessFailed,
            };
        };

        // Get native pointer to cons cell
        if (vm.virtual_memory) |_vmem| {
            const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(cell_addr, fptovp_table, 4) catch {
                return errors_module.VMError.MemoryAccessFailed;
            } else {
                return errors_module.VMError.MemoryAccessFailed;
            };

            const cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(native_ptr)));

            // Set CAR
            cons.setCAR(cell, car_value);

            // Encode CDR using helper function
            cons.setCDR(cell, cell_addr, cdr_value);

            // Push cons cell address
            try stack_module.pushStack(vm, cell_addr);
        } else {
            // No virtual memory - can't set up cons cell properly
            return errors_module.VMError.MemoryAccessFailed;
        }
    } else {
        // No storage - can't allocate cons cell
        return errors_module.VMError.MemoryAccessFailed;
    }
}

/// RPLACA: Replace CAR
/// Per rewrite documentation instruction-set/opcodes.md and data-structures/cons-cells.md
pub fn handleRPLACA(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Pop new CAR value and cons cell pointer
    const new_car = try stack_module.popStack(vm);
    const cons_cell_ptr = try stack_module.popStack(vm);

    if (cons_cell_ptr == 0) {
        return errors_module.VMError.InvalidAddress; // NIL is not a cons cell
    }

    // Get cons cell from memory
    if (vm.virtual_memory) |_vmem| {
        const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(cons_cell_ptr, fptovp_table, 4) catch {
            return errors_module.VMError.MemoryAccessFailed;
        } else {
            return errors_module.VMError.MemoryAccessFailed;
        };

        const cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(native_ptr)));

        // Handle indirect CDR encoding
        if (cell.cdr_code == cons.CDR_INDIRECT) {
            // CAR is stored in indirect cell
            const indirect_addr = cell.car_field;
            const indirect_native = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(indirect_addr, fptovp_table, 4) catch {
                return;
            } else {
                return;
            };
            const indirect_cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(indirect_native)));
            cons.setCAR(indirect_cell, new_car);
        } else {
            // Normal CAR update
            cons.setCAR(cell, new_car);
        }

        // Push cons cell pointer back
        try stack_module.pushStack(vm, cons_cell_ptr);
    } else {
        return errors_module.VMError.MemoryAccessFailed;
    }
}

/// RPLACD: Replace CDR
/// Per rewrite documentation instruction-set/opcodes.md and data-structures/cons-cells.md
pub fn handleRPLACD(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Pop new CDR value and cons cell pointer
    const new_cdr = try stack_module.popStack(vm);
    const cons_cell_ptr = try stack_module.popStack(vm);

    if (cons_cell_ptr == 0) {
        return errors_module.VMError.InvalidAddress; // NIL is not a cons cell
    }

    // Get cons cell from memory
    if (vm.virtual_memory) |_vmem| {
        const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(cons_cell_ptr, fptovp_table, 4) catch {
            return errors_module.VMError.MemoryAccessFailed;
        } else {
            return errors_module.VMError.MemoryAccessFailed;
        };

        const cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(native_ptr)));

        // Encode and set new CDR
        cons.setCDR(cell, cons_cell_ptr, new_cdr);

        // Push cons cell pointer back
        try stack_module.pushStack(vm, cons_cell_ptr);
    } else {
        return errors_module.VMError.MemoryAccessFailed;
    }
}

// ============================================================================
// Array Access Opcodes
// ============================================================================

/// GETAEL1: Get array element (1-byte index)
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleGETAEL1(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Pop array pointer from stack
    const array_ptr = try stack_module.popStack(vm);

    if (array_ptr == 0) {
        return errors_module.VMError.InvalidAddress; // NIL is not an array
    }

    // Get array header from memory
    if (vm.virtual_memory) |_vmem| {
        const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(array_ptr, fptovp_table, 4) catch {
            return errors_module.VMError.MemoryAccessFailed;
        } else {
            return errors_module.VMError.MemoryAccessFailed;
        };

        const header: *array.ArrayHeader = @as(*array.ArrayHeader, @ptrCast(@alignCast(native_ptr)));

        // Get array element
        const element_value = array.getArrayElement(header, index);

        // Push element value
        try stack_module.pushStack(vm, element_value);
    } else {
        return errors_module.VMError.MemoryAccessFailed;
    }
}

/// GETAEL2: Get array element (2-byte index)
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleGETAEL2(vm: *VM, index: u16) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Pop array pointer from stack
    const array_ptr = try stack_module.popStack(vm);

    if (array_ptr == 0) {
        return errors_module.VMError.InvalidAddress; // NIL is not an array
    }

    // Get array header from memory
    if (vm.virtual_memory) |_vmem| {
        const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(array_ptr, fptovp_table, 4) catch {
            return errors_module.VMError.MemoryAccessFailed;
        } else {
            return errors_module.VMError.MemoryAccessFailed;
        };
        const header: *array.ArrayHeader = @as(*array.ArrayHeader, @ptrCast(@alignCast(native_ptr)));

        // Get array element
        const element_value = array.getArrayElement(header, index);

        // Push element value
        try stack_module.pushStack(vm, element_value);
    } else {
        return errors_module.VMError.MemoryAccessFailed;
    }
}

/// SETAEL1: Set array element (1-byte index)
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleSETAEL1(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Pop value and array pointer from stack
    const value = try stack_module.popStack(vm);
    const array_ptr = try stack_module.popStack(vm);

    if (array_ptr == 0) {
        return errors_module.VMError.InvalidAddress; // NIL is not an array
    }

    // Get array header from memory
    if (vm.virtual_memory) |_vmem| {
        const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(array_ptr, fptovp_table, 4) catch {
            return errors_module.VMError.MemoryAccessFailed;
        } else {
            return errors_module.VMError.MemoryAccessFailed;
        };
        const header: *array.ArrayHeader = @as(*array.ArrayHeader, @ptrCast(@alignCast(native_ptr)));

        // Set array element
        array.setArrayElement(header, index, value);

        // Push array pointer back
        try stack_module.pushStack(vm, array_ptr);
    } else {
        return errors_module.VMError.MemoryAccessFailed;
    }
}

/// SETAEL2: Set array element (2-byte index)
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleSETAEL2(vm: *VM, index: u16) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Pop value and array pointer from stack
    const value = try stack_module.popStack(vm);
    const array_ptr = try stack_module.popStack(vm);

    if (array_ptr == 0) {
        return errors_module.VMError.InvalidAddress; // NIL is not an array
    }

    // Get array header from memory
    if (vm.virtual_memory) |_vmem| {
        const native_ptr = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(array_ptr, fptovp_table, 4) catch {
            return errors_module.VMError.MemoryAccessFailed;
        } else {
            return errors_module.VMError.MemoryAccessFailed;
        };
        const header: *array.ArrayHeader = @as(*array.ArrayHeader, @ptrCast(@alignCast(native_ptr)));

        // Set array element
        array.setArrayElement(header, index, value);

        // Push array pointer back
        try stack_module.pushStack(vm, array_ptr);
    } else {
        return errors_module.VMError.MemoryAccessFailed;
    }
}

// ============================================================================
// Comparison Opcodes
// ============================================================================

/// EQ: Equality test
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleEQ(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // EQ compares pointer equality
    const result: LispPTR = if (a == b) 1 else 0; // T or NIL
    try stack_module.pushStack(vm, result);
}

/// EQL: Equal test (deep comparison)
/// Per rewrite documentation instruction-set/opcodes.md
/// Recursively compares structures (not just pointer equality)
pub fn handleEQL(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // EQL does deep comparison
    const result = eqlDeep(vm, a, b) catch |err| {
        return switch (err) {
            error.MemoryAccessFailed => err,
            else => errors_module.VMError.MemoryAccessFailed,
        };
    };

    const result_value: LispPTR = if (result) 1 else 0; // T or NIL
    try stack_module.pushStack(vm, result_value);
}

/// Deep equality comparison helper
/// Recursively compares two Lisp values
fn eqlDeep(vm: *VM, a: LispPTR, b: LispPTR) errors.VMError!bool {

    // Pointer equality check first (fast path)
    if (a == b) {
        return true;
    }

    // Both NIL
    if (a == 0 and b == 0) {
        return true;
    }

    // One is NIL, other is not
    if (a == 0 or b == 0) {
        return false;
    }

    // Both are fixnums (odd addresses)
    if ((a & 1) != 0 and (b & 1) != 0) {
        return a == b; // Compare as integers
    }

    // Both are pointers (even addresses) - need to compare structures
    if ((a & 1) == 0 and (b & 1) == 0) {
        if (vm.virtual_memory) |_vmem| {
            // Try to access as cons cells
            const a_native = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(a, fptovp_table, 4) catch {
                return false;
            } else {
                return false;
            };
                return false; // Invalid address
            };
            const b_native = if (vm.fptovp) |fptovp_table| virtual_memory_module.translateAddress(b, fptovp_table, 4) catch {
                return false;
            } else {
                return false;
            };

            const a_cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(a_native)));
            const b_cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(b_native)));

            // Compare CAR recursively
            const car_equal = try eqlDeep(vm, cons.getCAR(a_cell), cons.getCAR(b_cell));
            if (!car_equal) {
                return false;
            }

            // Compare CDR recursively
            const a_cdr = cons.getCDR(a_cell, a);
            const b_cdr = cons.getCDR(b_cell, b);
            return try eqlDeep(vm, a_cdr, b_cdr);
        } else {
            // No virtual memory - fall back to pointer equality
            return a == b;
        }
    }

    // Different types (one fixnum, one pointer)
    return false;
}

/// LESSP: Less than test
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleLESSP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    const a_signed = @as(i32, @bitCast(@as(u32, a)));
    const b_signed = @as(i32, @bitCast(@as(u32, b)));
    const result: LispPTR = if (a_signed < b_signed) 1 else 0;

    try stack_module.pushStack(vm, result);
}

/// GREATERP: Greater than test
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleGREATERP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    const a_signed = @as(i32, @bitCast(@as(u32, a)));
    const b_signed = @as(i32, @bitCast(@as(u32, b)));
    const result: LispPTR = if (a_signed > b_signed) 1 else 0;

    try stack_module.pushStack(vm, result);
}

/// IGREATERP: Integer greater than
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleIGREATERP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    const a_signed = @as(i32, @bitCast(@as(u32, a)));
    const b_signed = @as(i32, @bitCast(@as(u32, b)));
    const result: LispPTR = if (a_signed > b_signed) 1 else 0;

    try stack_module.pushStack(vm, result);
}

// ============================================================================
// Type Checking Opcodes
// ============================================================================

/// NTYPX: Type check without type code operand
/// Per rewrite documentation instruction-set/opcodes.md
/// Type check using value's type tag
pub fn handleNTYPX(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const value = stack_module.getTopOfStack(vm);

    // Get type of value
    const value_type = getValueType(value, vm);

    // Push type code on stack
    try stack_module.pushStack(vm, @as(LispPTR, value_type));
}

/// TYPEP: Type predicate
/// Per rewrite documentation instruction-set/opcodes.md
/// Checks if TOS value matches the given type_code
/// Type codes:
///   0: NIL
///   1: Fixnum (small integer)
///   2: Pointer (general pointer)
///   3: Cons cell
///   4: Array
///   ... (other types)
pub fn handleTYPEP(vm: *VM, type_code: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const value = stack_module.getTopOfStack(vm);

    // Get type of value
    const value_type = getValueType(value, vm);

    // Check if value type matches requested type_code
    const result: LispPTR = if (value_type == type_code) 1 else 0;
    stack_module.setTopOfStack(vm, result);
}

/// DTEST: Test if TOS is specific atom
/// Per rewrite documentation instruction-set/opcodes.md
/// Tests if TOS value equals the atom at given atom_index
pub fn handleDTEST(vm: *VM, atom_index: u16) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // DTEST requires:
    // 1. Atom table lookup (from atom_index)
    // 2. Get atom object
    // 3. Compare with TOS value

    // TODO: Proper implementation needs:
    // 1. Atom table access (needs atom table structure)
    // 2. Atom object retrieval
    // 3. Value comparison

    const value = stack_module.getTopOfStack(vm);

    // For now, placeholder: compare with atom_index (will be properly implemented)
    const result: LispPTR = if (value == @as(LispPTR, atom_index)) 1 else 0;
    stack_module.setTopOfStack(vm, result);
}

/// UNWIND: Unwind stack frames
/// Per rewrite documentation instruction-set/opcodes.md
/// Unwinds stack frames based on unwind parameters
pub fn handleUNWIND(vm: *VM, unwind_params: u16) errors.VMError!void {
    // UNWIND requires:
    // 1. Parse unwind parameters (frame count, etc.)
    // 2. Unwind stack frames
    // 3. Restore previous frame state

    // TODO: Proper implementation needs:
    // 1. Frame unwinding logic
    // 2. Exception handling integration
    // 3. Cleanup of local variables

    _ = vm;
    _ = unwind_params; // Placeholder for now
}

/// Get type code for a LispPTR value
/// Returns type code based on value encoding
fn getValueType(value: LispPTR, vm: *VM) u8 {
    // NIL is type 0
    if (value == 0) {
        return 0; // NIL type
    }

    // Fixnums have low bit set (odd addresses)
    if ((value & 1) != 0) {
        return 1; // Fixnum type
    }

    // Even addresses are pointers
    // For now, we can't fully determine type without memory access
    // This is a simplified implementation that can be extended

    // If we have virtual memory, we could check the type tag
    // For now, return a generic pointer type (2)
    // TODO: When virtual memory is available, check actual type tags
    _ = vm; // Will be used when type tag lookup is implemented

    // Basic heuristics:
    // - Very small even values might be special constants
    // - Larger even values are likely pointers to objects

    // For now, return generic pointer type
    // This can be extended to check actual type tags from memory
    return 2; // Generic pointer type
}

/// FIXP: Fixnum predicate
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleFIXP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const value = stack_module.getTopOfStack(vm);
    // Fixnum check: low bit should be 0 (even address)
    const result: LispPTR = if ((value & 1) == 0) 1 else 0;
    stack_module.setTopOfStack(vm, result);
}

/// SMALLP: Small integer predicate
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleSMALLP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const value = stack_module.getTopOfStack(vm);
    // Small integer check: value fits in small integer range
    // Small integers are typically in range -32768 to 32767
    const value_signed = @as(i32, @bitCast(@as(u32, value)));
    const result: LispPTR = if (value_signed >= -32768 and value_signed <= 32767) 1 else 0;
    stack_module.setTopOfStack(vm, result);
}

/// LISTP: List predicate
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleLISTP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    const value = stack_module.getTopOfStack(vm);
    // LISTP: NIL or cons cell (even address, not a fixnum)
    const result: LispPTR = if (value == 0 or ((value & 1) == 0 and (value & 0x3) != 0)) 1 else 0;
    stack_module.setTopOfStack(vm, result);
}

// ============================================================================
// String/Character Opcodes
// ============================================================================

/// CHARCODE: Get character code from character object
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops character object from stack, pushes character code
/// Character objects are typically represented as fixnums with character code
pub fn handleCHARCODE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // Pop character object from stack
    const char_obj = try stack_module.popStack(vm);

    // Extract character code from character object
    // In Lisp, characters are typically represented as fixnums
    // Character code is typically in the low 8 bits (or 16 bits for wide chars)
    // For now, treat as 8-bit character code
    const char_code: LispPTR = char_obj & 0xFF;

    // Push character code
    try stack_module.pushStack(vm, char_code);
}

/// CHARN: Create character object from code
/// Per rewrite documentation instruction-set/opcodes.md
/// Pops character code from stack, pushes character object
/// Character code is typically a small integer (0-255 for 8-bit, 0-65535 for 16-bit)
pub fn handleCHARN(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // Pop character code from stack
    const char_code = try stack_module.popStack(vm);

    // Create character object from code
    // In Lisp, characters are typically represented as fixnums
    // Character code is stored in the low bits
    // For now, treat as 8-bit character code (mask to ensure valid range)
    const char_obj: LispPTR = char_code & 0xFF;

    // Push character object
    try stack_module.pushStack(vm, char_obj);
}

// ============================================================================
// Variable Access Opcodes
// ============================================================================

/// IVAR0-IVAR6: Local variable access
/// Per rewrite documentation instruction-set/opcodes.md and vm-core/stack-management.md
pub fn handleIVAR(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Get current frame
    const frame = vm.current_frame orelse {
        return errors_module.VMError.InvalidAddress; // No current frame
    };

    // IVar access: variables stored at nextblock offset
    const ivar_value = stack_module.getIVar(frame, index);
    try stack_module.pushStack(vm, ivar_value);
}

/// PVAR0-PVAR6: Parameter variable access
/// Per rewrite documentation instruction-set/opcodes.md and vm-core/stack-management.md
pub fn handlePVAR(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");

    // Get current frame
    const frame = vm.current_frame orelse {
        return errors_module.VMError.InvalidAddress; // No current frame
    };

    // PVar access: parameters stored right after frame header (FRAMESIZE offset)
    // Use helper function to get parameter value
    const pvar_value = stack_module.getPVar(frame, index);
    try stack_module.pushStack(vm, pvar_value);
}

/// FVAR0-FVAR6: Free variable access
/// Per rewrite documentation instruction-set/opcodes.md and vm-core/stack-management.md
/// Free variables are stored in PVar area after regular parameters
/// Each free variable occupies 2 words (low word and high word)
pub fn handleFVAR(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    const errors_module = @import("../utils/errors.zig");
    const function_header_module = @import("../data/function_header.zig");
    const types_module = @import("../utils/types.zig");

    // Get current frame
    const frame = vm.current_frame orelse {
        return errors_module.VMError.InvalidAddress; // No current frame
    };

    // Get function header from frame
    const fnheader_ptr = frame.fnheader;
    if (fnheader_ptr == 0) {
        return errors_module.VMError.InvalidAddress; // No function header
    }

    // Translate function header address to native pointer
    // For now, assume direct mapping (will need proper address translation later)
    const fnheader: *function_header_module.FunctionHeader = @as(*function_header_module.FunctionHeader, @ptrFromInt(@as(usize, fnheader_ptr)));

    // Free variables are stored in PVar area after regular parameters
    // PVars are stored as LispPTR (4 bytes each)
    // Free variables are stored as 2 DLwords (2 bytes each) = 4 bytes total
    // Free variable offset calculation:
    //   PVar area size = (pv + 1) * sizeof(LispPTR) = (pv + 1) * 4 bytes
    //   Free variable i starts at: PVar area size + (i * 4 bytes)
    const pvar_count = fnheader.pv + 1; // PVar count includes return value slot
    const pvar_area_size = @as(usize, pvar_count) * @sizeOf(LispPTR);
    const fvar_offset_bytes = pvar_area_size + (@as(usize, index) * 4); // Each FVAR is 4 bytes (2 DLwords)

    // Access free variable slot (2 words)
    const frame_addr = @intFromPtr(frame);
    const frame_size = @sizeOf(stack.FX);
    const pvar_base_addr = frame_addr + frame_size;

    // Get low word and high word (each is 2 bytes)
    const low_word_addr = pvar_base_addr + fvar_offset_bytes;
    const high_word_addr = low_word_addr + @sizeOf(types_module.DLword);

    const low_word_ptr: *types_module.DLword = @as(*types_module.DLword, @ptrFromInt(low_word_addr));
    const high_word_ptr: *types_module.DLword = @as(*types_module.DLword, @ptrFromInt(high_word_addr));

    const low_word = low_word_ptr.*;
    const high_word = high_word_ptr.*;

    // Check if unbound (LSB of low word indicates unbound)
    // For now, we'll skip the lookup and just return the value
    // TODO: Implement nfvlookup for unbound variables

    // Construct LispPTR from two words: (high_word << 16) | low_word
    const fvar_value: LispPTR = (@as(LispPTR, high_word) << 16) | @as(LispPTR, low_word);

    // Mask to get pointer (clear tag bits)
    const masked_value = fvar_value & 0xFFFFFFFE; // Clear LSB

    // Push value onto stack
    try stack_module.pushStack(vm, masked_value);
}

/// GVAR: Global variable access
/// Per rewrite documentation instruction-set/opcodes.md
/// Accesses global variable via atom index
pub fn handleGVAR(vm: *VM, atom_index: u16) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // GVAR access requires:
    // 1. Atom table lookup (from atom_index)
    // 2. Get DEFCELL from atom
    // 3. Get global variable value from DEFCELL
    // 4. Push value on stack

    // TODO: Proper implementation needs:
    // 1. Atom table access (needs atom table structure)
    // 2. DEFCELL lookup
    // 3. Global variable value extraction
    // For now, return NIL (will be properly implemented with atom tables)

    // Placeholder: push NIL for now
    try stack_module.pushStack(vm, 0);
    _ = atom_index; // Use atom_index when atom tables are implemented
}

/// ACONST: Atom constant
/// Per rewrite documentation instruction-set/opcodes.md
/// Pushes atom constant by atom index
pub fn handleACONST(vm: *VM, atom_index: u16) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // ACONST requires:
    // 1. Atom table lookup (from atom_index)
    // 2. Get atom object
    // 3. Push atom on stack

    // TODO: Proper implementation needs:
    // 1. Atom table access (needs atom table structure)
    // 2. Atom object creation/retrieval
    // For now, push atom_index as placeholder (will be properly implemented with atom tables)

    // Placeholder: push atom_index as atom pointer (will be properly implemented)
    try stack_module.pushStack(vm, @as(LispPTR, atom_index));
}

/// APPLYFN: Apply function
/// Per rewrite documentation instruction-set/opcodes.md
/// Applies a function to arguments on the stack
pub fn handleAPPLYFN(vm: *VM) errors.VMError!void {
    // APPLYFN requires:
    // 1. Function object on stack
    // 2. Arguments on stack
    // 3. Function application mechanism

    // TODO: Proper implementation needs:
    // 1. Get function object from stack
    // 2. Get argument count
    // 3. Apply function with arguments
    // 4. Handle spread arguments if needed

    // Placeholder: for now, this is similar to CALL but handles apply semantics
    // Will be properly implemented with function application system
    _ = vm;
}

/// CHECKAPPLY: Check function application
/// Per rewrite documentation instruction-set/opcodes.md
/// Validates function application arguments
pub fn handleCHECKAPPLY(vm: *VM) errors.VMError!void {
    // CHECKAPPLY requires:
    // 1. Function object on stack
    // 2. Argument count validation
    // 3. Type checking

    // TODO: Proper implementation needs:
    // 1. Get function object
    // 2. Check argument count matches function signature
    // 3. Validate argument types
    // 4. Signal error if validation fails

    // Placeholder: will be properly implemented with function validation
    _ = vm;
}

/// STKSCAN: Scan stack for variable
/// Per rewrite documentation instruction-set/opcodes.md and src/fvar.c
/// Scans stack frames for variable by atom index
pub fn handleSTKSCAN(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // STKSCAN requires:
    // 1. Atom index on TOS
    // 2. Scan current and previous frames
    // 3. Look up variable in name tables
    // 4. Return address of found value

    // TODO: Proper implementation needs:
    // 1. Get atom index from TOS
    // 2. Traverse stack frames (current and previous)
    // 3. Look up variable in each frame's name table
    // 4. Return address of variable value
    // 5. Handle unbound variables

    // Placeholder: for now, return NIL
    // Will be properly implemented with name table lookup
    const atom_index = stack_module.getTopOfStack(vm);
    _ = atom_index;
    stack_module.setTopOfStack(vm, 0); // Return NIL for now
}

/// FPLUS2: Floating-point addition
/// Per rewrite documentation instruction-set/opcodes.md
/// Adds two floating-point values
pub fn handleFPLUS2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // FPLUS2 requires:
    // 1. Two floating-point values on stack
    // 2. Floating-point addition
    // 3. Push result

    // TODO: Proper implementation needs:
    // 1. Extract floating-point values from LispPTR encoding
    // 2. Perform floating-point addition
    // 3. Encode result as LispPTR
    // 4. Push result

    // Placeholder: for now, treat as integer addition
    // Will be properly implemented with floating-point support
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result = a + b; // Simplified - needs proper FP handling
    try stack_module.pushStack(vm, result);
}

/// FDIFFERENCE: Floating-point subtraction
/// Per rewrite documentation instruction-set/opcodes.md
/// Subtracts two floating-point values
pub fn handleFDIFFERENCE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // TODO: Proper floating-point implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result = a - b; // Simplified - needs proper FP handling
    try stack_module.pushStack(vm, result);
}

/// FTIMES2: Floating-point multiplication
/// Per rewrite documentation instruction-set/opcodes.md
/// Multiplies two floating-point values
pub fn handleFTIMES2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // TODO: Proper floating-point implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result = a * b; // Simplified - needs proper FP handling
    try stack_module.pushStack(vm, result);
}

/// FQUOTIENT: Floating-point division
/// Per rewrite documentation instruction-set/opcodes.md
/// Divides two floating-point values
pub fn handleFQUOTIENT(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // TODO: Proper floating-point implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    if (b == 0) {
        return error.DivisionByZero;
    }
    const result = a / b; // Simplified - needs proper FP handling
    try stack_module.pushStack(vm, result);
}

/// FGREATERP: Floating-point greater-than comparison
/// Per rewrite documentation instruction-set/opcodes.md
/// Compares two floating-point values
pub fn handleFGREATERP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // TODO: Proper floating-point implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result: LispPTR = if (a > b) 1 else 0; // Simplified - needs proper FP handling
    stack_module.setTopOfStack(vm, result);
}

/// SLRETURN: Stack-relative return
/// Per rewrite documentation instruction-set/opcodes.md
/// Returns from function using stack-relative addressing
pub fn handleSLRETURN(vm: *VM) errors.VMError!void {
    // SLRETURN requires:
    // 1. Stack-relative return address
    // 2. Restore previous frame
    // 3. Return to caller

    // TODO: Proper implementation needs:
    // 1. Get return address from stack-relative location
    // 2. Restore previous frame
    // 3. Set PC to return address

    // Placeholder: similar to RETURN but uses stack-relative addressing
    // Will be properly implemented with frame management
    _ = vm;
}

/// EQUAL: Deep equality comparison
/// Per rewrite documentation instruction-set/opcodes.md
/// Performs deep equality comparison of two values
/// Helper: Check if LispPTR is NIL
fn isNil(ptr: LispPTR) bool {
    return ptr == 0;
}

/// Helper: Check if LispPTR is a fixnum (odd address)
fn isFixnum(ptr: LispPTR) bool {
    return (ptr & 1) != 0;
}

/// Helper: Check if LispPTR is a cons cell pointer (even address, not NIL, not fixnum)
fn isConsCell(ptr: LispPTR) bool {
    return ptr != 0 and (ptr & 1) == 0;
}

/// Helper: Recursive equality comparison
/// Per rewrite documentation instruction-set/opcodes.md
fn equalRecursive(vm: *VM, a: LispPTR, b: LispPTR) errors.VMError!bool {
    // Same pointer = equal
    if (a == b) return true;

    // NIL comparison
    if (isNil(a) or isNil(b)) return false;

    // Fixnum comparison
    if (isFixnum(a) and isFixnum(b)) {
        // Extract fixnum values (right shift by 1)
        const a_val = @as(i32, @bitCast(@as(u32, a >> 1)));
        const b_val = @as(i32, @bitCast(@as(u32, b >> 1)));
        return a_val == b_val;
    }

    // Type mismatch if one is fixnum and other isn't
    if (isFixnum(a) != isFixnum(b)) return false;

    // Cons cell comparison (recursive)
    if (isConsCell(a) and isConsCell(b)) {
        if (vm.virtual_memory) |_vmem| {
            // Get CAR values
            const a_native = virtual_memory_module.translateAddress(a, vmem.fptovp, 4) catch return false;
            const b_native = virtual_memory_module.translateAddress(b, vmem.fptovp, 4) catch return false;

            const a_cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(a_native)));
            const b_cell: *cons.ConsCell = @as(*cons.ConsCell, @ptrCast(@alignCast(b_native)));

            const a_car = cons.getCAR(a_cell);
            const b_car = cons.getCAR(b_cell);

            // Compare CAR recursively
            if (!try equalRecursive(vm, a_car, b_car)) return false;

            // Get CDR values
            const a_cdr = cons.decodeCDR(a_cell, a);
            const b_cdr = cons.decodeCDR(b_cell, b);

            // Compare CDR recursively
            return try equalRecursive(vm, a_cdr, b_cdr);
        } else {
            // Without virtual memory, can't access cons cells
            // Fall back to pointer comparison
            return a == b;
        }
    }

    // For other types (atoms, arrays, etc.), use pointer comparison for now
    // TODO: Implement proper comparison for atoms and arrays
    return a == b;
}

/// EQUAL: Deep equality comparison
/// Per rewrite documentation instruction-set/opcodes.md
/// Compares two values recursively (handles cons cells, numbers, atoms)
pub fn handleEQUAL(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // Pop two values from stack
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);

    // Perform recursive comparison
    const is_equal = try equalRecursive(vm, a, b);

    // Push result: T (1) if equal, NIL (0) if not
    const result: LispPTR = if (is_equal) 1 else 0;
    try stack_module.pushStack(vm, result);
}

/// MAKENUMBER: Create number object
/// Per rewrite documentation instruction-set/opcodes.md
/// Creates a number object from value on stack
/// For small integers, encodes as fixnum (odd address)
pub fn handleMAKENUMBER(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // Get value from stack
    const value = stack_module.getTopOfStack(vm);

    // Check if value is already a fixnum
    if (isFixnum(value)) {
        // Already a fixnum, no conversion needed
        return;
    }

    // Check if value is NIL (0)
    if (value == 0) {
        // NIL is not a number, keep as-is
        return;
    }

    // Try to encode as fixnum if it's a small integer
    // Fixnums are encoded as (value << 1) | 1
    // Small integers typically fit in 15 bits (signed: -16384 to 16383)
    const value_signed = @as(i32, @bitCast(@as(u32, value)));

    // Check if value fits in fixnum range
    // Fixnum range: typically -16384 to 16383 (15 bits signed)
    if (value_signed >= -16384 and value_signed <= 16383) {
        // Encode as fixnum: (value << 1) | 1
        const fixnum_value = (@as(u32, @bitCast(@as(i32, value_signed))) << 1) | 1;
        stack_module.setTopOfStack(vm, @as(LispPTR, fixnum_value));
        return;
    }

    // For larger integers or floats, would need bignum or float object creation
    // TODO: Implement bignum and float object creation
    // For now, keep value as-is (may be a pointer to number object)
}

/// RPLPTR_N: Replace pointer N
/// Per rewrite documentation instruction-set/opcodes.md
/// Replaces pointer at offset N
pub fn handleRPLPTR_N(vm: *VM, offset: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // RPLPTR_N requires:
    // 1. Pointer value on stack
    // 2. Target address on stack
    // 3. Replace pointer at offset

    // TODO: Proper implementation needs:
    // 1. Pop new pointer value
    // 2. Pop target address
    // 3. Replace pointer at target + offset

    // Placeholder: pop values but don't modify memory
    const new_ptr = try stack_module.popStack(vm);
    const target = try stack_module.popStack(vm);
    _ = new_ptr;
    _ = target;
    _ = offset;
}

/// ASSOC: Association list lookup
/// Per rewrite documentation instruction-set/opcodes.md
/// Looks up key in association list
pub fn handleASSOC(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // ASSOC requires:
    // 1. Key on stack
    // 2. Association list on stack
    // 3. Look up key-value pair
    // 4. Push value or NIL

    // TODO: Proper implementation needs:
    // 1. Pop key and association list
    // 2. Traverse association list (list of (key . value) pairs)
    // 3. Compare keys using EQ
    // 4. Push value if found, NIL if not

    // Placeholder: return NIL
    const key = try stack_module.popStack(vm);
    const alist = try stack_module.popStack(vm);
    _ = key;
    _ = alist;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// GVAR_: Set global variable
/// Per rewrite documentation instruction-set/opcodes.md
/// Sets global variable value
pub fn handleGVAR_(vm: *VM, atom_index: u16) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // GVAR_ requires:
    // 1. Value on stack
    // 2. Atom index
    // 3. Set global variable value

    // TODO: Proper implementation needs:
    // 1. Get value from stack
    // 2. Look up atom in atom table
    // 3. Set DEFCELL value

    // Placeholder: pop value but don't set variable
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = atom_index;
}

/// CMLASSOC: Case-insensitive association list lookup
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleCMLASSOC(vm: *VM) errors.VMError!void {
    // Similar to ASSOC but case-insensitive
    // Placeholder: same as ASSOC
    try handleASSOC(vm);
}

/// FMEMB: Fast member test
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleFMEMB(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // FMEMB requires:
    // 1. Item on stack
    // 2. List on stack
    // 3. Test membership

    // TODO: Proper implementation
    // Placeholder: return NIL
    const item = try stack_module.popStack(vm);
    const list = try stack_module.popStack(vm);
    _ = item;
    _ = list;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// CMLMEMBER: Case-insensitive member test
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleCMLMEMBER(vm: *VM) errors.VMError!void {
    // Similar to FMEMB but case-insensitive
    // Placeholder: same as FMEMB
    try handleFMEMB(vm);
}

/// FINDKEY: Find key in association list
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleFINDKEY(vm: *VM, key_index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // FINDKEY requires:
    // 1. Association list on stack
    // 2. Key index
    // 3. Find key-value pair

    // TODO: Proper implementation
    // Placeholder: return NIL
    const alist = try stack_module.popStack(vm);
    _ = alist;
    _ = key_index;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// CREATECELL: Create cons cell
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleCREATECELL(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // CREATECELL requires:
    // 1. CDR value on stack
    // 2. CAR value on stack
    // 3. Allocate cons cell
    // 4. Push cons cell pointer

    // TODO: Proper implementation needs:
    // 1. Pop CDR and CAR values
    // 2. Allocate cons cell from heap
    // 3. Set CAR and CDR
    // 4. Push cons cell pointer

    // Placeholder: similar to CONS but creates new cell
    // For now, just pop values
    const cdr = try stack_module.popStack(vm);
    const car = try stack_module.popStack(vm);
    _ = cdr;
    _ = car;
    try stack_module.pushStack(vm, 0); // Return NIL for now
}

/// BIN: Binary input
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleBIN(vm: *VM) errors.VMError!void {
    // BIN requires:
    // 1. Stream on stack
    // 2. Read binary data
    // 3. Push value

    // TODO: Proper implementation needs I/O subsystem
    // Placeholder: return NIL
    _ = vm;
}

/// BOUT: Binary output
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleBOUT(vm: *VM) errors.VMError!void {
    // BOUT requires:
    // 1. Value on stack
    // 2. Stream on stack
    // 3. Write binary data

    // TODO: Proper implementation needs I/O subsystem
    // Placeholder: pop values
    const stack_module = @import("stack.zig");
    const value = try stack_module.popStack(vm);
    const stream = try stack_module.popStack(vm);
    _ = value;
    _ = stream;
}

/// RESTLIST: Rest of list
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleRESTLIST(vm: *VM, count: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // RESTLIST requires:
    // 1. List on stack
    // 2. Skip count elements
    // 3. Push rest of list

    // TODO: Proper implementation needs:
    // 1. Pop list
    // 2. Traverse list count times using CDR
    // 3. Push remaining list

    // Placeholder: return list as-is
    const list = stack_module.getTopOfStack(vm);
    _ = list;
    _ = count;
}

/// MISCN: Miscellaneous N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleMISCN(vm: *VM, arg1: u8, arg2: u8) errors.VMError!void {
    // MISCN is a catch-all for miscellaneous operations
    // TODO: Proper implementation based on arguments
    // Placeholder: do nothing
    _ = vm;
    _ = arg1;
    _ = arg2;
}

/// RPLCONS: Replace cons
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleRPLCONS(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // RPLCONS requires:
    // 1. New CDR on stack
    // 2. New CAR on stack
    // 3. Cons cell pointer on stack
    // 4. Replace CAR and CDR

    // TODO: Proper implementation needs:
    // 1. Pop new CDR, new CAR, and cons cell pointer
    // 2. Modify cons cell in memory
    // 3. Push cons cell pointer

    // Placeholder: pop values
    const new_cdr = try stack_module.popStack(vm);
    const new_car = try stack_module.popStack(vm);
    const cell_ptr = try stack_module.popStack(vm);
    _ = new_cdr;
    _ = new_car;
    _ = cell_ptr;
    try stack_module.pushStack(vm, 0); // Return NIL for now
}

/// LISTGET: Get from list
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleLISTGET(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // LISTGET requires:
    // 1. Index on stack
    // 2. List on stack
    // 3. Get element at index
    // 4. Push element

    // TODO: Proper implementation needs:
    // 1. Pop index and list
    // 2. Traverse list index times using CDR
    // 3. Get CAR
    // 4. Push element

    // Placeholder: return NIL
    const index = try stack_module.popStack(vm);
    const list = try stack_module.popStack(vm);
    _ = index;
    _ = list;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// EVAL: Evaluate expression
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleEVAL(vm: *VM) errors.VMError!void {
    // EVAL requires:
    // 1. Expression on stack
    // 2. Evaluate expression
    // 3. Push result

    // TODO: Proper implementation needs:
    // 1. Pop expression
    // 2. Call evaluator
    // 3. Push result

    // Placeholder: return expression as-is
    _ = vm;
}

/// ENVCALL: Environment call
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleENVCALL(vm: *VM) errors.VMError!void {
    // ENVCALL requires:
    // 1. Function and arguments on stack
    // 2. Call in environment context
    // 3. Push result

    // TODO: Proper implementation needs:
    // 1. Get function and arguments
    // 2. Set up environment
    // 3. Call function
    // 4. Push result

    // Placeholder: similar to CALL but with environment
    _ = vm;
}

/// ATOMCELL_N: Atom cell N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleATOMCELL_N(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation needs atom table access
    _ = index;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// GETBASEBYTE: Get base byte
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleGETBASEBYTE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// INSTANCEP: Instance predicate
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleINSTANCEP(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const value = stack_module.getTopOfStack(vm);
    _ = value;
    stack_module.setTopOfStack(vm, 0); // Return NIL
}

/// BLT: BitBLT operation
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleBLT(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation needs graphics subsystem
    _ = vm;
}

/// MISC10: Miscellaneous 10
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleMISC10(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation
    _ = vm;
}

/// PUTBASEBYTE: Put base byte
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handlePUTBASEBYTE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const value = try stack_module.popStack(vm);
    _ = value;
}

/// GETBASE_N: Get base N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleGETBASE_N(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    _ = index;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// GETBASEPTR_N: Get base pointer N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleGETBASEPTR_N(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    _ = index;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// GETBITS_N_FD: Get bits N FD
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleGETBITS_N_FD(vm: *VM, arg1: u8, arg2: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    _ = arg1;
    _ = arg2;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// CMLEQUAL: Case-insensitive member equal
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleCMLEQUAL(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    _ = a;
    _ = b;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// PUTBASE_N: Put base N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handlePUTBASE_N(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = index;
}

/// PUTBASEPTR_N: Put base pointer N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handlePUTBASEPTR_N(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = index;
}

/// PUTBITS_N_FD: Put bits N FD
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handlePUTBITS_N_FD(vm: *VM, arg1: u8, arg2: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = arg1;
    _ = arg2;
}

/// ADDBASE: Add base
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleADDBASE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result = a + b;
    try stack_module.pushStack(vm, result);
}

/// VAG2: Vector add get 2
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleVAG2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// HILOC: High location
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleHILOC(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// LOLOC: Low location
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleLOLOC(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// IPLUS_N: Integer plus N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleIPLUS_N(vm: *VM, count: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation - add count values
    var sum: LispPTR = 0;
    var i: u8 = 0;
    while (i < count) : (i += 1) {
        const value = try stack_module.popStack(vm);
        sum += value;
    }
    try stack_module.pushStack(vm, sum);
}

/// IDIFFERENCE_N: Integer difference N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleIDIFFERENCE_N(vm: *VM, count: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    if (count == 0) {
        try stack_module.pushStack(vm, 0);
        return;
    }
    var result = try stack_module.popStack(vm);
    var i: u8 = 1;
    while (i < count) : (i += 1) {
        const value = try stack_module.popStack(vm);
        result -= value;
    }
    try stack_module.pushStack(vm, result);
}

/// BASE_LESSTHAN: Base less than
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleBASE_LESSTHAN(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result: LispPTR = if (a < b) 1 else 0;
    try stack_module.pushStack(vm, result);
}

/// UBFLOAT2: Unbox float 2
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleUBFLOAT2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper floating-point implementation
    const value = stack_module.getTopOfStack(vm);
    _ = value;
}

/// UBFLOAT1: Unbox float 1
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleUBFLOAT1(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper floating-point implementation
    const value = stack_module.getTopOfStack(vm);
    _ = value;
}

/// BOXIPLUS: Box integer plus
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleBOXIPLUS(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result = a + b;
    try stack_module.pushStack(vm, result);
}

/// BOXIDIFFERENCE: Box integer difference
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleBOXIDIFFERENCE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result = a - b;
    try stack_module.pushStack(vm, result);
}

/// FLOATBLT: Float BitBLT
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleFLOATBLT(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation needs graphics subsystem
    _ = vm;
}

/// FFTSTEP: FFT step
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleFFTSTEP(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation
    _ = vm;
}

/// MISC3: Miscellaneous 3
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleMISC3(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation
    _ = vm;
}

/// MISC4: Miscellaneous 4
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleMISC4(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation
    _ = vm;
}

/// UPCTRACE: Up counter trace
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleUPCTRACE(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation
    _ = vm;
}

/// CL_EQUAL: Case-insensitive equal
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleCL_EQUAL(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper case-insensitive comparison
    const b = try stack_module.popStack(vm);
    const a = try stack_module.popStack(vm);
    const result: LispPTR = if (a == b) 1 else 0; // Simplified
    try stack_module.pushStack(vm, result);
}

/// PVAR_SET: Set PVAR value
/// Per rewrite documentation instruction-set/opcodes.md
/// Sets parameter variable value
pub fn handlePVAR_SET(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // PVAR_SET requires:
    // 1. Value on stack
    // 2. Set PVAR at index

    // TODO: Proper implementation needs:
    // 1. Get value from stack
    // 2. Set PVAR at index in current frame

    // Placeholder: pop value but don't set variable
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = index;
}

/// ARG0: Argument 0
/// Per rewrite documentation instruction-set/opcodes.md
/// Gets first argument
pub fn handleARG0(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // ARG0 requires:
    // 1. Get argument 0 from current frame

    // TODO: Proper implementation needs:
    // 1. Access argument 0 from current frame

    // Placeholder: return NIL
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// IVARX_: Set IVAR X
/// Per rewrite documentation instruction-set/opcodes.md
/// Sets instance variable value
pub fn handleIVARX_(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // IVARX_ requires:
    // 1. Value on stack
    // 2. Set IVAR at index

    // TODO: Proper implementation
    // Placeholder: pop value
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = index;
}

/// FVARX_: Set FVAR X
/// Per rewrite documentation instruction-set/opcodes.md
/// Sets free variable value
pub fn handleFVARX_(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // FVARX_ requires:
    // 1. Value on stack
    // 2. Set FVAR at index

    // TODO: Proper implementation
    // Placeholder: pop value
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = index;
}

/// COPY: Copy value
/// Per rewrite documentation instruction-set/opcodes.md
/// Copies value on stack
pub fn handleCOPY(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // COPY requires:
    // 1. Value on stack
    // 2. Push copy of value

    // TODO: Proper implementation needs:
    // 1. Get value from stack
    // 2. Create copy (for GC purposes)
    // 3. Push copy

    // Placeholder: duplicate value
    const value = stack_module.getTopOfStack(vm);
    try stack_module.pushStack(vm, value);
}

/// MYARGCOUNT: My argument count
/// Per rewrite documentation instruction-set/opcodes.md
/// Gets argument count for current function
pub fn handleMYARGCOUNT(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // MYARGCOUNT requires:
    // 1. Get argument count from current frame

    // TODO: Proper implementation needs:
    // 1. Access function header
    // 2. Get argument count

    // Placeholder: return 0
    try stack_module.pushStack(vm, 0);
}

/// MYALINK: My argument link
/// Per rewrite documentation instruction-set/opcodes.md
/// Gets argument link for current function
pub fn handleMYALINK(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // MYALINK requires:
    // 1. Get argument link from current frame

    // TODO: Proper implementation needs:
    // 1. Access frame
    // 2. Get argument link

    // Placeholder: return NIL
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// SIC: Set instance cell
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleSIC(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // SIC requires:
    // 1. Value on stack
    // 2. Set instance cell at index

    // TODO: Proper implementation
    // Placeholder: pop value
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = index;
}

/// SNIC: Set named instance cell
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleSNIC(vm: *VM, index: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // SNIC requires:
    // 1. Value on stack
    // 2. Set named instance cell at index

    // TODO: Proper implementation
    // Placeholder: pop value
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = index;
}

/// SICX: Set instance cell X
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleSICX(vm: *VM, index: u16) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // SICX requires:
    // 1. Value on stack
    // 2. Set instance cell at index

    // TODO: Proper implementation
    // Placeholder: pop value
    const value = try stack_module.popStack(vm);
    _ = value;
    _ = index;
}

/// ELT: Element
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleELT(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// NTHCHC: Nth character
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleNTHCHC(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// SETA: Set array element
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleSETA(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const value = try stack_module.popStack(vm);
    const index = try stack_module.popStack(vm);
    const array_ptr = try stack_module.popStack(vm);
    _ = value;
    _ = index;
    _ = array_ptr;
}

/// RPLCHARCODE: Replace character code
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleRPLCHARCODE(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const new_code = try stack_module.popStack(vm);
    const char_obj = try stack_module.popStack(vm);
    _ = new_code;
    _ = char_obj;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// TYPECHECK: Type check
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleTYPECHECK(vm: *VM, type_code: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const value = stack_module.getTopOfStack(vm);
    _ = value;
    _ = type_code;
    stack_module.setTopOfStack(vm, 0); // Return NIL
}

/// BUSBLT: Bus BitBLT
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleBUSBLT(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation needs graphics subsystem
    _ = vm;
}

/// MISC8: Miscellaneous 8
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleMISC8(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation
    _ = vm;
}

/// UBFLOAT3: Unbox float 3
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleUBFLOAT3(vm: *VM, arg: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper floating-point implementation
    _ = arg;
    const value = stack_module.getTopOfStack(vm);
    _ = value;
}

/// TYPEMASK_N: Type mask N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleTYPEMASK_N(vm: *VM, mask: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    const value = stack_module.getTopOfStack(vm);
    _ = value;
    _ = mask;
    stack_module.setTopOfStack(vm, 0); // Return NIL
}

/// MISC7: Miscellaneous 7
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleMISC7(vm: *VM, arg: u8) errors.VMError!void {
    // TODO: Proper implementation
    _ = vm;
    _ = arg;
}

/// DRAWLINE: Draw line
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleDRAWLINE(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation needs graphics subsystem
    _ = vm;
}

/// STORE_N: Store N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleSTORE_N(vm: *VM, count: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    var i: u8 = 0;
    while (i < count) : (i += 1) {
        _ = try stack_module.popStack(vm);
    }
}

/// COPY_N: Copy N
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleCOPY_N(vm: *VM, count: u8) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // TODO: Proper implementation
    // Placeholder: duplicate top value count times
    const value = stack_module.getTopOfStack(vm);
    var i: u8 = 0;
    while (i < count) : (i += 1) {
        try stack_module.pushStack(vm, value);
    }
}

/// RAID: RAID operation
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleRAID(vm: *VM) errors.VMError!void {
    // TODO: Proper implementation needs I/O subsystem
    _ = vm;
}

/// JUMPXX: Extended jump XX
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleJUMPXX(vm: *VM) errors.VMError!void {
    // Similar to JUMPX but with different semantics
    // Placeholder: same as JUMPX
    _ = vm;
}

/// NFJUMPX: Not false jump extended
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleNFJUMPX(vm: *VM, offset: i16) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // NFJUMPX jumps if TOS is not false (not NIL)
    // Similar to TJUMPX but inverted logic
    const tos = stack_module.getTopOfStack(vm);
    _ = tos;
    _ = offset;
}

/// NTJUMPX: Not true jump extended
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleNTJUMPX(vm: *VM, offset: i16) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // NTJUMPX jumps if TOS is not true (is NIL)
    // Similar to FJUMPX but inverted logic
    const tos = stack_module.getTopOfStack(vm);
    _ = tos;
    _ = offset;
}

/// AREF2: Array reference 2
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleAREF2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // AREF2 requires:
    // 1. Array and indices on stack
    // 2. Get element at indices

    // TODO: Proper implementation needs:
    // 1. Pop indices and array
    // 2. Access multi-dimensional array element

    // Placeholder: return NIL
    const index2 = try stack_module.popStack(vm);
    const index1 = try stack_module.popStack(vm);
    const array_ptr = try stack_module.popStack(vm);
    _ = index2;
    _ = index1;
    _ = array_ptr;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// ASET2: Array set 2
/// Per rewrite documentation instruction-set/opcodes.md
pub fn handleASET2(vm: *VM) errors.VMError!void {
    const stack_module = @import("stack.zig");
    // ASET2 requires:
    // 1. Value, indices, and array on stack
    // 2. Set element at indices

    // TODO: Proper implementation needs:
    // 1. Pop value, indices, and array
    // 2. Set multi-dimensional array element

    // Placeholder: pop values
    const value = try stack_module.popStack(vm);
    const index2 = try stack_module.popStack(vm);
    const index1 = try stack_module.popStack(vm);
    const array_ptr = try stack_module.popStack(vm);
    _ = value;
    _ = index2;
    _ = index1;
    _ = array_ptr;
    try stack_module.pushStack(vm, 0); // Return NIL
}

/// GCONST: Global constant
/// Per rewrite documentation instruction-set/opcodes.md
/// Pushes global constant atom by atom index
pub fn handleGCONST(vm: *VM, atom_index: u16) errors.VMError!void {
    const stack_module = @import("stack.zig");

    // GCONST requires:
    // 1. Atom table lookup (from atom_index)
    // 2. Get global constant atom object
    // 3. Push atom on stack

    // TODO: Proper implementation needs:
    // 1. Atom table access (needs atom table structure)
    // 2. Global constant atom object creation/retrieval
    // For now, push atom_index as placeholder (will be properly implemented with atom tables)

    // Placeholder: push atom_index as atom pointer (will be properly implemented)
    try stack_module.pushStack(vm, @as(LispPTR, atom_index));
}
